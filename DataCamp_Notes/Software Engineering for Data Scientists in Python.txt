Software Engineering for Data Scientists in Python

Course Description
Data scientists can experience huge benefits by learning concepts from the field of software engineering, allowing them to more easily reutilize their code and share it with collaborators. In this course, you'll learn all about the important ideas of modularity, documentation, & automated testing, and you'll see how they can help you solve Data Science problems quicker and in a way that will make future you happy. You'll even get to use your acquired software engineering chops to write your very own Python package for performing text analytics.

====================================================================================================================================

1
Software Engineering & Data Science
FREE
0%
Why should you as a Data Scientist care about Software Engineering concepts? Here we'll cover specific Software Engineering concepts and how these important ideas can revolutionize your Data Science workflow!



_____________________________________________________________________________________________________________________________

Software engineering concepts:

Modularity
Documentation
Testing
Version Control & Git


Benets of automated testing:

Save time over manualtesting
Find & x more bugs
Run tests anytime/anywhere

_____________________________________________________________________________________________________________________________


Python modularity in the wild
In the slides, we covered 3 ways that you can write modular code with Python: packages, classes, and methods. For reference, you can see the example code we reviewed below.

# Import the pandas PACKAGE
import pandas as pd

# Create some example data
data = {'x': [1, 2, 3, 4], 
        'y': [20.1, 62.5, 34.8, 42.7]}

# Create a dataframe CLASS object
df = pd.DataFrame(data)

# Use the plot METHOD
df.plot('x', 'y')
In this exercise, you'll utilize a class & a method from the popular package numpy.

Instructions
100 XP
Complete the import statement to load the numpy package.
Use numpy's array class to define arr.
Use arr's sort method to sort the numpy array.


# import the numpy package
import numpy as np

# create an array class object
arr = np.array([8, 6, 7, 5, 3, 0, 9])

# use the sort method
arr.sort()

# print the sorted array
print(arr)

_____________________________________________________________________________________________________________________________


Leveraging documentation
When writing code for Data Science, it's inevitable that you'll need to install and use someone else's code. You'll quickly learn that using someone else's code is much more pleasant when they use good software engineering practices. In particular, good documentation makes the right way to call a function obvious. In this exercise you'll use python's help() method to view a function's documentation so you can determine how to correctly call a new method.

The list words has been loaded in your session.

Instructions 1/2
50 XP
1
2
View the documentation of the Counter.most_common method using the help function. Note, you need to run the import statement before completing this step.

# load the Counter function into our environment
from collections import Counter

# View the documentation for Counter.most_common
help(Counter.most_common)



<script.py> output:
    Help on function most_common in module collections:
    
    most_common(self, n=None)
        List the n most common elements and their counts from the most
        common to the least.  If n is None, then list all element counts.
        
        >>> Counter('abcdeabcdabcaba').most_common(3)
        [('a', 5), ('b', 4), ('c', 3)]
				
				

Instructions 2/2
50 XP
2
Correctly call Counter.most_common() by reading its documentation.
Print the results stored in top_5_words.



# load the Counter function into our environment
from collections import Counter

# View the documentation for Counter.most_common
help(Counter.most_common)

# use Counter to find the top 5 most common words
top_5_words = Counter(words).most_common(5)

# display the top 5 most common words
print(top_5_words)


<script.py> output:
    Help on function most_common in module collections:
    
    most_common(self, n=None)
        List the n most common elements and their counts from the most
        common to the least.  If n is None, then list all element counts.
        
        >>> Counter('abcdeabcdabcaba').most_common(3)
        [('a', 5), ('b', 4), ('c', 3)]
    
    [('@DataCamp', 299), ('to', 263), ('the', 251), ('in', 164), ('RT', 158)]
_____________________________________________________________________________________________________________________________

Using pycodestyle
We saw earlier that pycodestyle can be run from the command line to check a file for PEP 8 compliance. Sometimes it's useful to run this kind of check from a Python script.

In this exercise, you'll use pycodestyle's StyleGuide class to check multiple files for PEP 8 compliance. Both files accomplish the same task, but they differ greatly in formatting and readability. You can view the contents of the files by following their links below.

Instructions
100 XP
Import the pycodestyle package
Create an instance of StyleGuide named style_checker.
There are two files that we'll be checking; they're named nay_pep8.py and yay_pep8.py. Pass a list containing these file names to our style_checker's check_files method.
print the results of our style check to the console. Make sure to read the output!

# Import needed package
import pycodestyle

# Create a StyleGuide instance
style_checker = pycodestyle.StyleGuide()

# Run PEP 8 check on multiple files
result = style_checker.check_files(['nay_pep8.py', 'yay_pep8.py'])

# Print result of PEP 8 style check
print(result.messages)

<script.py> output:
    nay_pep8.py:1:1: E265 block comment should start with '# '
    nay_pep8.py:2:6: E225 missing whitespace around operator
    nay_pep8.py:4:2: E131 continuation line unaligned for hanging indent
    nay_pep8.py:5:6: E131 continuation line unaligned for hanging indent
    nay_pep8.py:6:1: E122 continuation line missing indentation or outdented
    nay_pep8.py:7:1: E265 block comment should start with '# '
    nay_pep8.py:8:1: E402 module level import not at top of file
    nay_pep8.py:9:1: E265 block comment should start with '# '
    nay_pep8.py:10:1: E302 expected 2 blank lines, found 0
    nay_pep8.py:10:18: E231 missing whitespace after ','
    nay_pep8.py:11:2: E111 indentation is not a multiple of four
    nay_pep8.py:12:2: E111 indentation is not a multiple of four
    nay_pep8.py:14:1: E265 block comment should start with '# '
    nay_pep8.py:15:1: E305 expected 2 blank lines after class or function definition, found 1
    nay_pep8.py:16:11: E111 indentation is not a multiple of four
    nay_pep8.py:16:17: E225 missing whitespace around operator
    nay_pep8.py:16:32: E222 multiple spaces after operator
    nay_pep8.py:16:32: E251 unexpected spaces around keyword / parameter equals
    nay_pep8.py:16:38: E231 missing whitespace after ','
    nay_pep8.py:16:44: E221 multiple spaces before operator
    nay_pep8.py:16:44: E251 unexpected spaces around keyword / parameter equals
    nay_pep8.py:16:47: E251 unexpected spaces around keyword / parameter equals
    nay_pep8.py:17:11: E111 indentation is not a multiple of four
    nay_pep8.py:17:17: E201 whitespace after '('
    nay_pep8.py:17:25: E202 whitespace before ')'
    nay_pep8.py:17:27: W292 no newline at end of file
    {'E225': 'missing whitespace around operator', 'E122': 'continuation line missing indentation or outdented', 'E231': "missing whitespace after ','", 'E402': 'module level import not at top of file', 'E222': 'multiple spaces after operator', 'E251': 'unexpected spaces around keyword / parameter equals', 'E202': "whitespace before ')'", 'E111': 'indentation is not a multiple of four', 'E221': 'multiple spaces before operator', 'E201': "whitespace after '('", 'E131': 'continuation line unaligned for hanging indent', 'E265': "block comment should start with '# '", 'E305': 'expected 2 blank lines after class or function definition, found 1', 'E302': 'expected 2 blank lines, found 0', 'W292': 'no newline at end of file'}
		
		_____________________________________________________________________________________________________________________________
		
		Conforming to PEP 8
As we've covered, there are tools available to check if your code conforms to the PEP 8 guidelines. One possible way to stay compliant is to use an IDE that warns you when you accidentally stray from the style guide. Another way to check code is to use the pycodestyle package.

The results below show the output of running pycodestyle check against the code shown in your editor. The leading number in each line shows how many occurrences there were of that particular violation.

my_script.py:2:2:  E225 missing whitespace around operator
my_script.py:2:7:  E231 missing whitespace after ','
my_script.py:2:9:  E231 missing whitespace after ','
my_script.py:5:7:  E201 whitespace after '('
my_script.py:5:11: E202 whitespace before ')'
Instructions
100 XP
Leverage the output of pycodestyle to edit the code to be compliant with PEP 8

# Assign data to x
x = [8, 3, 4]

# Print the data
print(x)

		
_____________________________________________________________________________________________________________________________

PEP 8 in documentation
So far we've focused on how PEP 8 affects functional pieces of code. There are also rules to help make comments and documentation more readable. In this exercise, you'll be fixing various types of comments to be PEP 8 compliant.

The result of a pycodestyle style check on the code can be seen below.

my_script.py:2:15: E261 at least two spaces before inline comment
my_script.py:5:16: E262 inline comment should start with '# '
my_script.py:11:1: E265 block comment should start with '# '
my_script.py:13:2: E114 indentation is not a multiple of four (comment)
my_script.py:13:2: E116 unexpected indentation (comment)
Instructions
100 XP
Leverage the output of pycodestyle to edit the code's comments to be compliant with PEP 8

def print_phrase(phrase, polite=True, shout=False):
    if polite: 
        # It's generally polite to say please
        phrase = 'Please ' + phrase

    if shout:  
        # All caps looks like a written shout
        phrase = phrase.upper() + '!!'

    print(phrase)

# Politely ask for help
print_phrase('help me', polite=True)

# Shout about a discovery
print_phrase('eureka', shout=True)


====================================================================================================================================

2
Writing a Python Module
0%
Become a fully fledged Python package developer by writing your first package! You'll learn how to structure and write Python code that you can be installed, used, and distributed just like famous packages such as NumPy and Pandas.


_____________________________________________________________________________________________________________________________
Minimal package requirements
What are the minimal requirements to make an import-able python package?

A directory with a blank file named __init__.py.

_____________________________________________________________________________________________________________________________
Naming packages
We covered the PEP 8 guidelines for naming packages. In this exercise, you'll use that knowledge to identify a package following the requirements.

For additional reference, you can view the PEP 8 section on package naming here

Instructions
100 XP
The possible package names to import are the following: text_analyzer, textAnalyzer, TextAnalyzer, & __text_analyzer__
import the package from the list above that follows the PEP 8 naming conventions.

# Import the package with a name that follows PEP 8
import text_analyzer

_____________________________________________________________________________________________________________________________


Recognizing packages
The structure of your directory tree is printed below. You'll be working in the file my_script.py that you can see in the tree.

recognizing_packages
├── MY_PACKAGE
│   └── _init_.py
├── package
│   └── __init__.py
├── package_py
│   └── __init__
│       └── __init__.py
├── py_package
│   └── __init__.py
├── pyackage
│   └── init.py
└── my_script.py
Instructions
100 XP
Use the information from the context to identify the packages in the directory that follow the minimal structure.
import the two packages that follow the minimal package requirements.
Use help to print information about each imported package.


# Import local packages
import package
import py_package

# View the help for each package
help(package)
help(py_package)


In [1]: # Import local packages
        import package
        import py_package
        
        # View the help for each package
        help(package)
        help(py_package)
Help on package package:

NAME
    package

PACKAGE CONTENTS


FILE
    /tmp/tmphgagh5a6/package/__init__.py


Help on package py_package:

NAME
    py_package

PACKAGE CONTENTS


FILE
    /tmp/tmphgagh5a6/py_package/__init__.py

<script.py> output:
    Help on package package:
    
    NAME
        package
    
    PACKAGE CONTENTS
    
    
    FILE
        /tmp/tmprzpo4evi/package/__init__.py
    
    
    Help on package py_package:
    
    NAME
        py_package
    
    PACKAGE CONTENTS
    
    
    FILE
        /tmp/tmprzpo4evi/py_package/__init__.py
				
_____________________________________________________________________________________________________________________________

Adding functionality to your package
Thanks to your work before, you already have a skeleton for your python package. In this exercise, you will work to define the functions needed for a text analysis of word usage.

In the file counter_utils.py, you will write 2 functions to be a part of your package: plot_counter and sum_counters. The structure of your package can be seen in the tree below. For the coding portions of this exercise, you will be working in the file counter_utils.py.

text_analyzer
├── __init__.py
└── counter_utils.py
Instructions 1/3
35 XP
1
2
3
Define top_items using plot_counter's inputs
	
	# Import needed functionality
from collections import Counter

def plot_counter(counter, n_most_common=5):
  # Subset the n_most_common items from the input counter
  top_items = counter.most_common(n_most_common)
  # Plot `top_items`
  plot_counter_most_common(top_items)
			
_____________________________________________________________________________________________________________________________
Adding functionality to your package
Thanks to your work before, you already have a skeleton for your python package. In this exercise, you will work to define the functions needed for a text analysis of word usage.

In the file counter_utils.py, you will write 2 functions to be a part of your package: plot_counter and sum_counters. The structure of your package can be seen in the tree below. For the coding portions of this exercise, you will be working in the file counter_utils.py.

text_analyzer
├── __init__.py
└── counter_utils.py
Instructions 2/3
35 XP
2
3
Return the correct output from sum_counters

# Import needed functionality
from collections import Counter

def sum_counters(counters):
  # Sum the inputted counters
  return sum(counters, Counter())

_____________________________________________________________________________________________________________________________

Question
You just wrote two functions for your package in the file counter_utils.py named plot_counter & sum_counters. Which of the following lines would correctly import these functions in __init__.py using relative import syntax?

from .counter_utils import plot_counter, sum_counters


_____________________________________________________________________________________________________________________________


Using your package's new functionality
You've now created some great functionality for text analysis to your package. In this exercise, you'll leverage your package to analyze some tweets written by DataCamp & DataCamp users.

The object word_counts is loaded into your environment. It contains a list of Counter objects that contain word counts from a sample of DataCamp tweets.

The structure you've created can be seen in the tree below. You'll be working in my_script.py.

working_dir
├── text_analyzer
│    ├── __init__.py
│    ├── counter_utils.py
└── my_script.py
Instructions
100 XP
import your text_analyzer at the top of the script.
Use the sum_counters function from text_analyzer to aggregate all the Counters in word_counts.
Use the plot_counter function from text_analyzer to visualize the tweet's most used words while tweeting.

# Import local package
import text_analyzer

# Sum word_counts using sum_counters from text_analyzer
word_count_totals = text_analyzer.sum_counters(word_counts)

# Plot word_count_totals using plot_counter from text_analyzer
text_analyzer.plot_counter(word_count_totals)

_____________________________________________________________________________________________________________________________

Writing requirements.txt
We covered how having a requirements.txt file can help your package be more portable by allowing your users to easily recreate its intended environment. In this exercise, you will be writing the contents of a requirements file to a python variable.

Note, in practice, the code you write in this exercise would be written to it's own txt file instead of a variable in your python session.

Instructions
100 XP
Write the requirement for matplotlib with at least version 3.0.0 or above.
Write the requirement for numpy version 1.15.4 exactly.
Write the requirement for pandas with at most version 0.22.0.
Write a non-version specific requirement for pycodestyle

requirements = """
matplotlib>=3.0.0
numpy==1.15.4
pandas<=0.22.0
pycodestyle
"""
_____________________________________________________________________________________________________________________________

Installing package requirements
You've now written a requirements.txt file to recreate your package's environment using a pip install command. Given that you are running a shell session in the work_dir structure shown below, what command would properly recreate the my_package environment from requirements.txt?

work_dir/
├── my_package
│   ├── __init__.py
│   └── utils.py
├── requirements.txt
└── setup.py

pip install -r requirements.txt

Correct! pip install -r allows you to install everything listed in a requirements file.
_____________________________________________________________________________________________________________________________

Creating setup.py
In order to make your package installable by pip you need to create a setup.py file. In this exercise you will create this file for the text_analyzer package you've been building.

Instructions
100 XP
import the needed function, setup, from the setuptools package.
Complete the name & packages arguments; keep in mind your package is located in a directory named text_analyzer.
List yourself as the author.
# Import needed function from setuptools
from setuptools import setup

# Create proper setup to be used by pip
setup(name='text_analyzer',
      version='0.0.1',
      description='Perform and visualize a text anaylsis.',
      author='Mikiko',
      packages=['text_analyzer'])


<script.py> output:
    running bdist_rpm
    running egg_info
    creating text_analyzer.egg-info
    writing top-level names to text_analyzer.egg-info/top_level.txt
    writing text_analyzer.egg-info/PKG-INFO
    writing dependency_links to text_analyzer.egg-info/dependency_links.txt
    writing manifest file 'text_analyzer.egg-info/SOURCES.txt'
    reading manifest file 'text_analyzer.egg-info/SOURCES.txt'
    writing manifest file 'text_analyzer.egg-info/SOURCES.txt'
    creating dist
    writing 'dist/text_analyzer.spec'
    
    Perfect! Thanks to creating this setup.py file you can now pip install your package and even publish it to PyPi!
    
    _____________________________________________________________________________________________________________________________
    
    
Listing requirements in setup.py
We created a setup.py file earlier, but we forgot to list our dependency on matplotlib in the install_requires argument. In this exercise you will practice listing your version specific dependencies by correcting the setup.py you previously wrote for your text_analyzer package.

Instructions
100 XP
import the needed function, setup, from the setuptools package.
List yourself as the author.
Specify your install_requires to require matplotlib version 3.0.0 or above.


# Import needed function from setuptools
from setuptools import setup

# Create proper setup to be used by pip
setup(name='text_analyzer',
      version='0.0.1',
      description='Perform and visualize a text anaylsis.',
      author='Mikiko',
      packages=['text_analyzer'],
      install_requires=['matplotlib>=3.0.0'])



<script.py> output:
    running bdist_rpm
    running egg_info
    creating text_analyzer.egg-info
    writing top-level names to text_analyzer.egg-info/top_level.txt
    writing text_analyzer.egg-info/PKG-INFO
    writing dependency_links to text_analyzer.egg-info/dependency_links.txt
    writing requirements to text_analyzer.egg-info/requires.txt
    writing manifest file 'text_analyzer.egg-info/SOURCES.txt'
    reading manifest file 'text_analyzer.egg-info/SOURCES.txt'
    writing manifest file 'text_analyzer.egg-info/SOURCES.txt'
    creating dist
    writing 'dist/text_analyzer.spec'
    
    Package setup for text_analyzer by Mikiko was succesful!
    
    
Great work! When users pip install your package the correct version of matplotlib will be automatically handled by pip.

====================================================================================================================================

3
Utilizing Classes
0%
Object Oriented Programming is a staple of Python development. By leveraging classes and inheritance your Python package will become a much more powerful tool for your users.

_____________________________________________________________________________________________________________________________
Writing a class for your package
We've covered how classes can be written in Python. In this exercise, you'll be creating the beginnings of a Document class that will be a foundation for text analysis in your package. Once the class is written you will modify your package's __init__.py file to make it easily accessible by your users.

Below is the structure of where you'll be working.

working_dir
├── text_analyzer
│    ├── __init__.py
│    ├── counter_utils.py
│    ├── document.py
└── my_script.py
Instructions 1/2
50 XP
1
2
Instructions 1/2
50 XP
1
2
You are working in document.py
Finish the def statement that will create a new Document instance when a user calls Document().
Use your knowledge of PEP 8 conventions to complete the definition of the newly named class method.
Take Hint (-15 XP)

# Define Document class
class Document:
    """A class for text analysis
    
    :param text: string of text to be analyzed
    :ivar text: string of text to be analyzed; set by `text` parameter
    """
    # Method to create a new instance of MyClass
    def __init__(self, text):
        # Store text parameter to the text attribute
        self.text = text



_____________________________________________________________________________________________________________________________

Using your package's class
You just wrote the beginnings of a Document class that you'll build upon to perform text analysis. In this exercise, you'll test out its current functionality of storing text.

Below is the document tree that you've built up so far when developing your package. You'll be working in my_script.py.

working_dir
├── text_analyzer
│    ├── __init__.py
│    ├── counter_utils.py
│    ├── document.py
└── my_script.py
Instructions
100 XP
import your text_analyzer package.
Create an instance of Document with the datacamp_tweet variable that's been loaded into your session.
Print the contents of the text attribute of your newly created Document instance.


# Import custom text_analyzer package
import text_analyzer

# Create an instance of Document with datacamp_tweet
my_document = text_analyzer.Document(text=datacamp_tweet)

# Print the text attribute of the Document instance
print(my_document.text)


_____________________________________________________________________________________________________________________________

Writing a non-public method
In the lesson, we covered how to add functionality to classes using non-public methods. By defining methods as non-public you're signifying to the user that the method is only to be used inside the package.

In this exercise, you will define a non-public method that will be leveraged by your class to count words.

Instructions
100 XP
Counter from collections has been loaded into your environment, as well as the function tokenize.
Add a method named count_words as a non-public method
Give your non-public method the functionality to count the contents tokens attribute using Counter
Utilize your new function in the __init__ method

class Document:
  def __init__(self, text):
    self.text = text
    # Tokenize the document with non-public tokenize method
    self.tokens = self._tokenize()
    # Perform word count with non-public count_words method
    self.word_counts = self._count_words()

  def _tokenize(self):
    return tokenize(self.text)
	
  # non-public method to tally document's word counts with Counter
  def _count_words(self):
    return Counter(self.tokens)

_____________________________________________________________________________________________________________________________

Using your class's functionality
You've now added additional functionality to your Document class's __init__ method that automatically processes text for your users. In this exercise, you'll act as one of those users to see the benefits of your hard work.

The Document class (copied below) has been loaded into your environment (complete with your new updates).

class Document:
  def __init__(self, text):
    self.text = text
    # pre tokenize the document with non-public tokenize method
    self.tokens = self._tokenize()
    # pre tokenize the document with non-public count_words
    self.word_counts = self._count_words()

  def _tokenize(self):
    return tokenize(self.text)

  # non-public method to tally document's word counts with Counter
  def _count_words(self):
    return Counter(self.tokens)
Instructions
100 XP
Instructions
100 XP
Create a new Document instance from the datacamp_tweets data set loaded into your environment. The datacamp_tweets object is a single string containing hundreds of tweets written by DataCamp & DataCamp users.
Print the first 5 tokens from datacamp_doc.
Print the top 5 most common words that were calculated by the non-public _count_words() method automatically in the Document.__init__ method.
Take Hint (-30 XP)

# create a new document instance from datacamp_tweets
datacamp_doc = Document(datacamp_tweets)

# print the first 5 tokens from datacamp_doc
print(datacamp_doc.tokens[:5])

# print the top 5 most used words in datacamp_doc
print(datacamp_doc._count_words().most_common(5))


<script.py> output:
    ['[DataCamp]', 'Introduction', 'to', 'H', 'O']
    [('DataCamp', 322), ('to', 263), ('the', 251), ('in', 163), ('RT', 158)]

Superb! Thanks to the functionality you added to the __init__ method, your users get the benefits of tokenization and word counts without any extra effort.


_____________________________________________________________________________________________________________________________

Using inheritance to create a class
You've previously written a Document class for text analysis, but your NLP project will now have a focus on Social Media data. Your general Document class might be useful later so it's best not destroy it while your focus shifts to tweets.

Instead of copy-pasting the already written functionality, you will use the principles of 'DRY' and inheritance to quickly create your new SocialMedia class.

Instructions
100 XP
Document has been preloaded in the session.
Complete the class statement to create a SocialMedia class that inherits from Document.
Define SocialMedia's __init__() method that initializes a Document.


# Define a SocialMedia class that is a child of the `Document class`
class SocialMedia(Document):
    def __init__(self, text):
        Document.__init__(self, text)

Fantastic! Thanks to inheritance your SocialMedia class already has all the functionality of the Document class, and you were able to accomplish this by staying DRY.

_____________________________________________________________________________________________________________________________

Adding functionality to a child class
You've just written a SocialMedia class that inherits functionality from Document. As of now, the SocialMedia class doesn't have any functionality different from Document. In this exercise, you will build feature's into SocialMedia to specialize it for use with Social Media data.

For reference, the definition of Document can be seen below.

class Document:
    # Initialize a new Document instance
    def __init__(self, text):
        self.text = text
        # Pre tokenize the document with non-public tokenize method
        self.tokens = self._tokenize()
        # Pre tokenize the document with non-public count_words
        self.word_counts = self._count_words()

    def _tokenize(self):
        return tokenize(self.text)

    # Non-public method to tally document's word counts
    def _count_words(self):
        # Use collections.Counter to count the document's tokens
        return Counter(self.tokens)
Instructions 1/2
50 XP
1
2
Instructions 1/2
50 XP
1
2
The function filter_word_counts has been loaded in your session. Use help to see its proper usage.
Finish the _count_hashtags method using filter_word_counts so that only words_counts starting with # remain.


# Define a SocialMedia class that is a child of the `Document class`
class SocialMedia(Document):
    def __init__(self, text):
        Document.__init__(self, text)
        self.hashtag_counts = self._count_hashtags()
        
    def _count_hashtags(self):
        # Filter attribute so only words starting with '#' remain
        return filter_word_counts(self.word_counts,'#')



Fill in the first line ofSocialMedia's __init__ method using the parent class to properly utilize inheritance.
Properly call the _count_mentions method in __init__ to add a new feature to SocialMedia.


# Define a SocialMedia class that is a child of the `Document class`
class SocialMedia(Document):
    def __init__(self, text):
        Document.__init__(self, text)
        self.hashtag_counts = self._count_hashtags()
        self.mention_counts = self._count_mentions()
        
    def _count_hashtags(self):
        # Filter attribute so only words starting with '#' remain
        return filter_word_counts(self.word_counts, first_char='#')
    
    def _count_mentions(self):
        # Filter attribute so only words starting with '@' remain
        return filter_word_counts(self.word_counts, first_char='@')
_____________________________________________________________________________________________________________________________

Using your child class
Thanks to the power of inheritance you were able to create a feature-rich, SocialMedia class based on its parent, Document. Let's see some of these features in action.

Below is the full definition of SocialMedia for reference. Additionally, SocialMedia has been added to __init__.py for ease of use.

class SocialMedia(Document):
    def __init__(self, text):
        Document.__init__(self, text)
        self.hashtag_counts = self._count_hashtags()
        self.mention_counts = self._count_mentions()

    def _count_hashtags(self):
        # Filter attribute so only words starting with '#' remain
        return filter_word_counts(self.word_counts, first_char='#')      

    def _count_mentions(self):
        # Filter attribute so only words starting with '@' remain
        return filter_word_counts(self.word_counts, first_char='@')
Instructions
100 XP
import your text_analyzer custom package.
Define dc_tweets as an instance of SocialMedia with the preloaded datacamp_tweets object as the text.
print the 5 most_common mentioned users in the data using the appropriate dc_tweets attribute.
Use text_analyzer's plot_counter method to plot the most used hashtags in the data using the appropriate dc_tweets attribute.


# Import custom text_analyzer package
import text_analyzer

# Create a SocialMedia instance with datacamp_tweets
dc_tweets = text_analyzer.SocialMedia(text=datacamp_tweets)

# Print the top five most most mentioned users
print(dc_tweets.mention_counts.most_common(5))

# Plot the most used hashtags
text_analyzer.plot_counter(dc_tweets.hashtag_counts)

_____________________________________________________________________________________________________________________________



# Import custom text_analyzer package
import text_analyzer

# Create a SocialMedia instance with datacamp_tweets
dc_tweets = text_analyzer.SocialMedia(text=datacamp_tweets)

# Print the top five most most mentioned users
print(dc_tweets.mention_counts.most_common(5))

# Plot the most used hashtags
text_analyzer.plot_counter(dc_tweets.hashtag_counts)

# Import needed package
import text_analyzer

# Create instance of document
my_doc = text_analyzer.Document(datacamp_tweets)


# Import needed package
import text_analyzer

# Create instance of document
my_doc = text_analyzer.Document(datacamp_tweets)

# Run help on my_doc's plot method
help(my_doc.plot_counts())

# Plot the word_counts of my_doc
my_doc.plot_counts()


_____________________________________________________________________________________________________________________________

Creating a grandchild class
In this exercise you will be using inheritance to create a Tweet class from your SocialMedia class. This new grandchild class of Document will be able to tackle Twitter specific details such as retweets.

Instructions
100 XP
Complete the class statement so that Tweets inherits from SocialMedia. SocialMedia has already been loaded in your environment.
Use super() to call the __init__ method of the parent class.
Define retweet_text. Use help to complete the call to filter_lines with the correct parameter name. filter_lines has already been loaded in your environment.
return retweet_text from _process_retweets as an instance of SocialMedia.

# Define a Tweet class that inherits from SocialMedia
class Tweets(SocialMedia):
    def __init__(self, text):
        # Call parent's __init__ with super()
        super().__init__(text)
        # Define retweets attribute with non-public method
        self.retweets = self._process_retweets()

    def _process_retweets(self):
        # Filter tweet text to only include retweets
        retweet_text = filter_lines(self.text, first_chars='RT')
        # Return retweet_text as a SocialMedia object
        return SocialMedia(retweet_text)



_____________________________________________________________________________________________________________________________

sing inherited methods
You've now defined a Tweets class that's inherited methods from both Document and SocialMedia. In this exercise, you'll use inherited methods to visualize text from both tweets and retweets.

Instructions 1/3
35 XP
1
2
3
import your text_analyzer package.
Define my_tweets as an instance of Tweets using the datacamp_tweets data that has been pre-loaded into your environment.

# Import needed package
import text_analyzer

# Create instance of Tweets
my_tweets = text_analyzer.Tweets(datacamp_tweets)


Use the plot_counts method to plot the top 'hashtag_counts'.
Make sure to check the documentation for my_tweets.plot_counts.

# Import needed package
import text_analyzer

# Create instance of Tweets
my_tweets = text_analyzer.Tweets(datacamp_tweets)

# Plot the most used hashtags in the tweets
my_tweets.plot_counts('hashtag_counts')

Use the plot_counts method of the retweets attribute to plot the most used hashtags in the retweets subset of the data.

# Import needed package
import text_analyzer

# Create instance of Tweets
my_tweets = text_analyzer.Tweets(datacamp_tweets)

# Plot the most used hashtags in the retweets
my_tweets.retweets.plot_counts()


Use the plot_counts method of the retweets attribute to plot the most used hashtags in the retweets subset of the data.


# Import needed package
import text_analyzer

# Create instance of Tweets
my_tweets = text_analyzer.Tweets(datacamp_tweets)

# Plot the most used hashtags in the retweets
my_tweets.retweets.plot_counts('hashtag_counts')




====================================================================================================================================

4
Maintainability
0%
You've now written a fully functional Python package for text analysis! To make maintaining your project as easy as possible we'll leverage best practices around concepts such as documentation and unit testing.


_____________________________________________________________________________________________________________________________


Identifying good comments
We learned about what characteristics make a 'good' comment. In this exercise, you'll apply this knowledge to identify a function that utilizes comment best practices.

Instructions
100 XP
print the text variable that has been pre-loaded into your environment.
print the result of calling the function with more useful commenting on text.


import re

def extract_0(text):
    # match and extract dollar amounts from the text
    return re.findall(r'\$\d+\.\d\d', text)

def extract_1(text):
    # return all matches to regex pattern
    return re.findall(r'\$\d+\.\d\d', text)

# Print the text
print(text)

# Print the results of the function with better commenting
print(extract_0(text))

<script.py> output:
    Our competitor pricing is $10.50 an inch. Our price is $125.00 a foot.
    ['$10.50', '$125.00']
    
 _____________________________________________________________________________________________________________________________
 
 Identifying proper docstrings
We covered how to write fully-fledged docstrings. Before writing one of your own, this exercise will help you practice by having you identify a properly formatted docstring.

In this exercise, you'll be using the functions goldilocks, rapunzel, mary, and sleeping_beauty which have been loaded in your environment.

Instructions 1/2
50 XP
1
2
Run help on each of the 4 functions to view their docstrings.


Define result using the function that has the most complete docstring; only 1 of the 4 contains all the sections we covered. Call the function without any parameters.
print the result of the most well documented function.


# Run the help on all 4 functions
help(goldilocks)
help(rapunzel)
help(mary)
help(sleeping_beauty)

# Execute the function with most complete docstring
result = rapunzel()

# Print the result
print(result)

_____________________________________________________________________________________________________________________________

Writing docstrings
We just learned some about the benefits of docstrings. In this exercise, you will practice writing docstrings that can be utilized by a documentation generator like Sphinx.

Note that your docstring submission must match the solution exactly. If you find yourself getting it wrong several times, it may be a good idea to refresh the sample code and start over.

Instructions
100 XP
Complete the portions of the docstring that document the parameters
Complete the portion of the docstring describing the return value
Complete the example function usage in the docstring

# Complete the function's docstring
def tokenize(text, regex=r'[a-zA-z]+'):
  """Split text into tokens using a regular expression

  :param text: text to be tokenized
  :param regex: regular expression used to match tokens using re.findall 
  :return: a list of resulting tokens

  >>> tokenize('the rain in spain')
  ['the', 'rain', 'in', 'spain']
  """
  return re.findall(regex, text, flags=re.IGNORECASE)

# Print the docstring
help(tokenize)

_____________________________________________________________________________________________________________________________

Using good function names
A good function name can go a long way for both user and maintainer understanding. A good function name is descriptive and describes what a function does. In this exercise, you'll choose a name for a function that will help aid in its readability when used.

Instructions
100 XP
The math module has been pre-loaded into your environment to be able to use its sqrt function.
Give function the best possible name from the following options: do_stuff, hypotenuse_length, square_root_of_leg_a_squared_plus_leg_b_squared, pythagorean_theorem.
Complete the docstring's example with the function's name.
print the result of using the newly named function to find the length of the hypotenuse for a right triangle with legs of length 6 & 8.


def hypotenuse_length(leg_a, leg_b):
    """Find the length of a right triangle's hypotenuse

    :param leg_a: length of one leg of triangle
    :param leg_b: length of other leg of triangle
    :return: length of hypotenuse
    
    >>> hypotenuse_length(3, 4)
    5
    """
    return math.sqrt(leg_a**2 + leg_b**2)


# Print the length of the hypotenuse with legs 6 & 8
print(hypotenuse_length(6,8))

_____________________________________________________________________________________________________________________________

Using good variable names
Just like functions, descriptive variable names can make your code much more readable. In this exercise, you'll write some code using good variable naming practices.

There's not always a clear best name for a variable. The exercise has been written to try and make a clear best choice from the provided options.

Instructions
100 XP
Choose the best variable name to hold the sample of pupil diameter measurements in millimeters from the following choices: d, diameter, pupil_diameter, or pupil_diameter_in_millimeters.
Take the mean of the measurements and assign it to a variable. Choose the best variable name to hold this mean from the following options: m, mean, mean_diameter, or mean_pupil_diameter_in_millimeters.
Print the resulting average pupil diameter.


from statistics import mean

# Sample measurements of pupil diameter in mm
pupil_diameter = [3.3, 6.8, 7.0, 5.4, 2.7]

# Average pupil diameter from sample
mean_diameter = mean(pupil_diameter)

print(mean_diameter)

_____________________________________________________________________________________________________________________________

Refactoring for readability
Refactoring longer functions into smaller units can help with both readability and modularity. In this exercise, you will refactor a function into smaller units. The function you will be refactoring is shown below. Note, in the exercise, you won't be using docstrings for the sake of space; in a real application, you should include documentation!

def polygon_area(n_sides, side_len):
    """Find the area of a regular polygon

    :param n_sides: number of sides
    :param side_len: length of polygon sides
    :return: area of polygon

    >>> round(polygon_area(4, 5))
    25
    """
    perimeter = n_sides * side_len

    apothem_denominator = 2 * math.tan(math.pi / n_sides)
    apothem = side_len / apothem_denominator

    return perimeter * apothem / 2
Instructions
100 XP
Move the logic for calculating the perimeter into the polygon_perimeter function.
Complete the definition of the polygon_apothem function, by moving the logic seen in the context. The math module has already been imported for you.
Utilize the new unit functions to complete the definition of polygon_area.
Use the more unitized polygon_area to calculate the area of a regular hexagon with legs of size 10.


def polygon_perimeter(n_sides, side_len):
    return n_sides * side_len

def polygon_apothem(n_sides, side_len):
    denominator = 2 * math.tan(math.pi / n_sides)
    return side_len / denominator

def polygon_area(n_sides, side_len):
    perimeter = polygon_perimeter(n_sides, side_len)
    apothem = polygon_apothem(n_sides, side_len)

    return perimeter * apothem / 2

# Print the area of a hexagon with legs of size 10
print(polygon_area(n_sides=6, side_len=10))


_____________________________________________________________________________________________________________________________
Using doctest
We just learned about doctest, which, if you're writing full docstrings with examples, is a simple way to minimally test your functions. In this exercise, you'll get some hands-on practice testing and debugging with doctest.

The following have all be pre-loaded in your environment: doctest, Counter, and text_analyzer.

Note that your docstring submission must match the solution exactly. If you find yourself getting it wrong several times, it may be a good idea to refresh the sample code and start over.

Instructions
100 XP
Complete the input code of the example in the docstring for sum_counters.
Complete the docstring example by filling in the expected output.
Run the testmod function from doctest to test your function's example code.

def sum_counters(counters):
    """Aggregate collections.Counter objects by summing counts

    :param counters: list/tuple of counters to sum
    :return: aggregated counters with counts summed

    >>> d1 = text_analyzer.Document('1 2 fizz 4 buzz fizz 7 8')
    >>> d2 = text_analyzer.Document('fizz buzz 11 fizz 13 14')
    >>> sum_counters([d1.word_counts, d2.word_counts])
    Counter({'fizz': 4, 'buzz': 2})
    """
    return sum(counters, Counter())

doctest.testmod()

_____________________________________________________________________________________________________________________________

sing pytest
doctest is a great tool, but it's not nearly as powerful as pytest. In this exercise, you'll write tests for your SocialMedia class using the pytest framework.

Instructions 1/2
50 XP
1
2
Question
Before you start writing tests, you need to be working in an appropriately named file for pytest to find your test. Which of the following would be the best, valid name for file containing tests for the SocialMedia class?


import the SocialMedia class.
Complete the name of the test function so it is run by pytest.
Use the appropriate keyword to test that the hashtag_counts are as expected.


from collections import Counter
from text_analyzer import SocialMedia

# Create an instance of SocialMedia for testing
test_post = 'learning #python & #rstats is awesome! thanks @datacamp!'
sm_post = SocialMedia(test_post)

# Test hashtag counts are created properly
def test_social_media_hashtags():
    expected_hashtag_counts = Counter({'#python': 1, '#rstats': 1})
    assert sm_post.hashtag_counts == expected_hashtag_counts


_____________________________________________________________________________________________________________________________

Documenting classes for Sphinx
sphinx is a great tool for rendering documentation as HTML. In this exercise, you'll write a docstring for a class that can be taken advantage of by sphinx.

Note that your docstring submission must match the solution exactly. If you find yourself getting it wrong several times, it may be a good idea to refresh the sample code and start over.

Instructions
100 XP
import the Document class from the text_analyzer package for use in the class definition
Complete the line of the docstring dealing with the parameters of the __init__ method
Complete the docstring by filling out the documentation for the attributes or 'instance variables' of the SocialMedia class


from text_analyzer import Document

class SocialMedia(Document):
    """Analyze text data from social media
    
    :param text: social media text to analyze

    :ivar hashtag_counts: Counter object containing counts of hashtags used in text
    :ivar mention_counts: Counter object containing counts of @mentions used in text
    """
    def __init__(self, text):
        Document.__init__(self, text)
        self.hashtag_counts = self._count_hashtags()
        self.mention_counts = self._count_mentions()

_____________________________________________________________________________________________________________________________

Identifying tools
Which of following lists of tools best corresponds to the 3 software engineering concepts of Modularity, Documentation, & Automated Testing. The correct answer will have the tools listed in the order that best corresponds to which concept they help you with.

After this exercise you will be nearly done with the course! If you enjoyed it, feel free to send Adam a thank you via Twitter - he'll appreciate it! Tweet to Adam


Code Climate, Sphinx, & Travis CI

Great job! Code Climate can help point out if your code isn't modular, Sphinx can help create documentation for your project using your docstrings, and Travis CI can automatically run your tests every time you add code.
