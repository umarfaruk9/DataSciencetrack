--------------------Introduction and Lists -------------------------------------

Container Sequences - Hold other types of data
Sepcific container sequences -inc lists, dictionarys, tuples

Lists -
  Hold data in order it was added
  Mutable
  Index to acccess a specific element
  
  
  Ex: List
                  cookies = ['chocolate chip', 'peanut butter', 'oatmeal', 'sugar']
                  coookies.append('Tirggel')       #add new items to lists using the append method
                  print(cookies)
                  print(cookies[2])
                  
                  
 Combining lists
        Can either use operator or .extend() - merges a list into another list at the end
        
        Operator method (1):
        
                  cakes = ['strawberry', 'vanilla']
                  desserts = cookies + cakes
                  print(desserts)
                  
        Extends Method (2):

Find and Remove Elements in a List 
        .index() method locates the position of a data element in a list
        
                  position = cookies.index('sugar')
                  print(position)
                  cookies[3]
        
        
        .pop() method removes an item from a list and allow you to save it
        
                  name = cookies.pop(position)
                  print(name)
                  print(cookies)

 Iterating and sorting over a list
      for loops are the most common way of iterating over a list
 
                  for cookie in cookies :
                        print(cookie)
                        
      sorted() function sorts data in numerical or alpjabetical order and returns a new list 
      
                  print(cookies)
                  sorted_cookies = sorted(cookies)
                  
                  
  .extend() - allows youto combine a list with another array type (list, set, tuple)
  .append() - adding individual data elements to a list by using the .append() method
  
                  >>>>>>>>>>>>>> Code SNippet: Manipulating lists
                                          # Create a list containing the names: baby_names
                                          baby_names = ['Ximena', 'Aliza', 'Ayden', 'Calvin']

                                          # Extend baby_names with 'Rowen' and 'Sandeep'
                                          baby_names.extend(['Rowen','Sandeep'])

                                          # Print baby_names
                                          print(baby_names)

                                          # Find the position of 'Aliza': position
                                          position = baby_names.index('Aliza')

                                          # Remove 'Aliza' from baby_names
                                          baby_names.pop(position)

                                          # Print baby_names
                                          print(baby_names)
                                          
                                          


                     >>>>>>>>>>>>>>>>> Code SNippet: Looping over lists 
                                     # Create the empty list: baby_names
                                          baby_names = []

                                          # Loop over records 
                                          for row in records:
                                              # Add the name to the list
                                              baby_names.append(row[3])

                                          # Sort the names in alphabetical order
                                          for name in sorted(baby_names):
                                              # Print each name
                                              print(name)
         





---------------------------------- Meet the tuples---------------------------------
Tuples - like lists
    Holds data in order
    Can access individual elements inside a tuple with index
    
    Easier to process and more efficient
    Immutable - can ensure data isn't altered
    Can create tuples by pairing up elements
    Can use tuple unpacking to expand a tuple into named variables that represent each element in the tuple
    
    
Zipping and Unpacking    
        tuples are commonly created by zipping lists together with zip()
        Two lists: us_ookies ,  in_cookies
        
                                      top_pairs = zip(us_cookies, in_cookies)
                                      print(top_pairs)
                                      
         tuple unpacking is a very exporessive way for working with data
            -allows us to assign the elements of a tuple to named variables for later use
            -syntax allows us to create more readable and less error prone code
            
            start by putting both variables as the target of the assignment statement separated by a comma
            Then assign the first tuple in our top pairs list to them
                                     us_num_1, in_num_1 = top_pairs[0]   
            
         
        More unpacking in Loops
                Can use tuple unpacking to separate a list of tuples into their elements as we loop over them
                

                                        for us_cookie, in_cookie in top_pairs:
                                                    print(in_cookie)
                                                    print(us_cookie)

          Enumerating Positions        
                  Another use of tuple unpacking helps us keep track of which element in the iterable or list we are currently on 
                  Often we want to know what the index is of an element in the iterable is. The enumerate function enabled us to do that by creating tuples where the first element of the tuple is the index of the element in the original list, then the element itself. 
                  We can use this to track rankings in our data or skip elements we are not interested in. 
                  Here I'm going to enumerate our top pairs list and split that resulting tuple into index and item. 
                  I can also use tuple unpacking on the item to get all three components separately. 
                  This can be exceptionally powerful. 
                  
                          - Another useful tuple creation method is the eunmerate() function
                          Enumeration is used in loops to return the postion and the data in that position while looping
                          
                                                    for idx, item in enumerate(top_pairs) :
                                                            us_cookie, in_cookie = items
                                                            print(idx, us_cookie, in_cookie)
                                                            
                  BE careful when making tuples!
                      Can use different methods like zip(), enumerate() or () t make tuples
                                  
                                                    items = ('vanilla', 'chocolate')
                                  
                   But beware of trailing commas!
                   
                                                       item2 = 'butter',
                                                            
                                                            
                                                            
    Using and unpacking tuples
Tuples are made of several items just like a list, but they cannot be modified in any way. It is very common for tuples to be used to represent data from a database. If you have a tuple like ('chocolate chip cookies', 15) and you want to access each part of the data, you can use an index just like a list. However, you can also "unpack" the tuple into multiple variables such as type, count = ('chocolate chip cookies', 15) that will set type to 'chocolate chip cookies' and count to 15.

Often you'll want to pair up multiple array data types. The zip() function does just that. It will return a list of tuples containing one element from each list passed into zip().

When looping over a list, you can also track your position in the list by using the enumerate() function. The function returns the index of the list item you are currently on in the list and the list item itself.

You'll practice using the enumerate() and zip() functions in this exercise, in which your job is to pair up the most common boy and girl names.                                                         
     
     
     
     
     
     
     >>>>>>>>>>>>>>> Code SNippet: Using and Unpacking Tuples:
                                         # Pair up the boy and girl names: pairs
                                          pairs = zip(girl_names, boy_names)

                                          # Iterate over pairs
                                          for idx, pair in enumerate(pairs):
                                              # Unpack pair: girl_name, boy_name
                                              girl_name, boy_name = pair      #### this is similar to naming the components of the tuple
                                              # Print the rank and names associated with each rank
                                              print('Rank {}: {} and {}'.format(idx, girl_name, boy_name))

                       
                                    
   >>>>>>>>>>>>>>>>>>>>> Code Snippet: Making Tuples by Accident:
                                       # Create the normal variable: normal
                            normal = 'simple'

                            # Create the mistaken variable: error
                            error = 'trailing comma',

                            # Print the types of the variables
                            print(type(normal))
                            print(type(error))                   
       
       
       
       
       
  --------------------------------Sets for unordered and unique data ------------------------------------     
       
       Sets - 
          Excellent for finding all the unique values in a column of your data, a list of elements, or even rows from a file.
          We use sets when we want to store unique data elements in an unordered fashion.
          Sets are mutable, so can add and remove elements from them. 
          Just going to scratch surface of what can be done with sets. Has many more capabilities that align wuth set theory from math. 
          
          
       
       Creating Sets
                -Sets are created from a list. 
                
                                cookies_eated_today =['choclate chip', 'peanut butter', 'chocolate chip', 'oatmeal cream', 'chocolate chip']
                                types_of_cookies_eaten = set(cookies_eaten_today)
                                print(types_of_cookies_eaten)
                                
                                
        Modifying a Set
                  .add() - adds single elements; will only add the element if it is unique, otherwise it just continues on -When working with a set, will use the add method to add a new element to the set
                  
                  .update() - merges in another set or list; can add multiple items using the update method; update method takes a list of items and adds each one to the set if it is not present
                  
                
                                            types_of_cookies_eaten.add('biscotti')
                                            types_of_cookies_eaten.add('chocolate chip')
                                            print(types_of_cookies_eaten)
                                            
                                            cookies_hugo_ate = ['chocolate chip','anzac']
                                            types_of_cookies_eaten.update(cookies_hugo_ate)
                                            print(types_of_cookies_eaten_
                                            
            Removing data from sets
                      .discard() - safely removes an element from the sey by its value - No error will be thrown if the data isn't found - When removing data from a set, we can use the discard method to safely remove an element from the set by its vlaue
                      
                      .pop()  - Can also use the pop method to remove and return an arbitrary element from the set (KeyError when empty) 
                      
                          
                          
                                          types_of_cookies_eaten.discard('biscotti')
                                          print(types_of_cookies_eaten)
                                            
                                            
                                            
             Set Operations - Similarities
                      .union()  - set method returns a set of all the names (or)
                      .intersection() - method identifies overlapping data (and) 
             
                      
                      
                                                     cookies_jason_ate = set(['chocolate chip', 'oatmeal cookie', 'peanut butter'])
                                                     
                                                     cookies_hugo_ate = set (['chocolate chip', 'anzac'])
                                                     
                                                     cookies_jason_ate.union(cookies_hugo_ate)
                                                     cookies_jason_ate.intersection(cookies_hugo_ate)
                                                     
                        .difference()   - method identifies data present in the set on which the method was used that is not in the arguments (-). The target we call the difference method on is important as that will be the basis for our differences. 
                        
                                                      cookies_jason_ate.difference(cookies_hugo_ate)    ### See the cookies that Jason ate that Hugo didn't
                                                      
                                                      cookies_hugo_ate.difference(cookies_jason_ate)    ### see the cookies that hugo ate and jason ddin't
                                                      
                                                      
                                                      
                                        >>>>>>>>>>>>>>> Finding all the data and the overlapping data between sets
                                                        Code Snippet: # Find the union: all_names
                                                                        all_names = baby_names_2011.union(baby_names_2014)

                                                                        # Print the count of names in all_names
                                                                        print(len(all_names))

                                                                        # Find the intersection: overlapping_names
                                                                        overlapping_names = baby_names_2011.intersection(baby_names_2014)

                                                                        # Print the count of names in overlapping_names
                                                                        print(len(overlapping_names))

                                         >>>>>>>>>>>>>>>>>> Determining set differences
                                                            Code Snippet: # Create the empty set: baby_names_2011
                                                                            baby_names_2011 = set()

                                                                            # Loop over records and add the names from 2011 to the baby_names_2011 set
                                                                            for row in records:
                                                                                # Check if the first column is '2011'
                                                                                if row[0] == '2011':
                                                                                    # Add the fourth column to the set
                                                                                    baby_names_2011.add(row[3])

                                                                            # Find the difference between 2011 and 2014: differences
                                                                            differences = baby_names_2011.difference(baby_names_2014)

                                                                            # Print the differences
                                                                            print(differences)
                                                                            
                                                                            
                                                                            
                                                                            
                                                                            
--------------------------------------Using Dictionaries----------------------------------------------
Dictionaries are useful for storing key/value pairs, grouping data by time or structuring hierarchical data like org charts.

                                                        
Creating and Looping through dictionaries
            -Hold data in key/value pairs - while they key must be alphanumeric, the value can be any other data type
            -Nestable - Use a dictionary as the value of a key within a dictionary - also possible to nest dictionaries so that you can work with grouped or hierarchical data
            -Iterable - We can also iterate over the keys and values of a dictionary
                       -We can also iterate over the items of a dictionary, which are tuples of the key value pairs!
            -Create dictionaries using the dict() or the braces method {}           

             
             
          -Have list of tuples in this example to turn into a dictionary, so can quickly find the zipcode without having to scan the whole list
          
                                    art_galleries = {}                   ###Created empty dictionary
                                    
                                    for name, zip_code in galleries :                ##### use tuple unpacking as loop over the galleries list that contains data
                                              art_galleries[name] = zip_code         ###### Inside the loop, set the name of the gallery as the key in my dictionary and the zip code as the value
                                              
                                              
                                    for name in art_galleries :                 ########### Finally want to fund the last 5 art gallery names
                                               print(name)
                                  
  
                                                        
                        By default, when using sorted on a dictionary or looping over a dictionary we loop over the keys, so will print the keys by name.
                        
                        Accessing dictionary vale=ues by key -- 
                               
                               Safely finding by key -- getting a value from a dictionary is done by using the key as an index;
                                                             however, if the key isn't present you will get an ugly exception that stops the execution of your code (KeyError)
                                                    While you could use Python exception hadling, this is so common that dictionaries have a get() method just for this problem
                                         .get() method allows you to safely access a key without errir or exception handling (allows you to safely get a value from a key by passing the key)
                                                         -if a key is not in the dictionary, .get() returns None by default or you can supply a value to return
                                                                    -you can optionally supply a second argument which will be returned instead of None
                                                             
                                        ex:
                                        
                                                    art_galleries.get('Louvre','Not Found')                
                                           If you do supply a valid key to the get() method it will return the value from the dictionary 
                                            
         
         -WQorking with nested data
                    -Can also nest dictionaries to group data or establish hierarchy 
                                .keys() method shows the keys for a given dictionary
                                
                                
                                                  art_galleries.keys()
                                                  dict_keys(['10021','10013','10001','10011'])
                                                  
                                                  print(art_galleries['10027'])
                                                  art_galleries['10027']['Inner City Art Ga;;ery Inc']  ##Getting the phone number of one of the galleries by using the gallery name which us the nested dictionary's key aas a secondary key
                                                  
                     -Nesting dictionaries is a very commom way to deal with repeating data structures such as yearly data, grouped, or hierarchical data such as organization reporting structures
                     -You can access nested values by providing multiple indices to the dictionary or using the get mothod on AN INDEX
                     
                                          -Can be accessed using multiple indices or the .get() method on an index
                                                  
         
         
         >>>>>>>>>>>>>>>>>> Code snippet: Creatijg and looping through dictionaries
                                     # Create an empty dictionary: names
                            names = {}

                            # Loop over the girl names
                            for name, rank in female_baby_names_2012:
                                # Add each name to the names dictionary using rank as the key
                                names[rank] = name

                            # Sort the names list by rank in descending order and slice the first 10 items
                            for rank in sorted(names,reverse=True)[:10]:
                                # Print each item
                                print(names[rank])


          >>>>>>>>>>>>>Code Snippet: Safely Finding by Key
          As demonstrated in the video, if you attempt to access a key that isn't present in a dictionary, you'll get a KeyError. One option to handle this type of error is to use a try: except: block. You can learn more about error handling in Python Data Science Toolbox (Part 1), specifically in this video.

Python provides a faster, more versatile tool to help with this problem in the form of the .get() method. The .get() method allows you to supply the name of a key, and optionally, what you'd like to have returned if the key is not found.
                             
                             
                             # Safely print rank 7 from the names dictionary
                                print(names.get(7))

                                # Safely print the type of rank 100 from the names dictionary
                                print(type(names.get(100)))

                                # Safely print rank 105 from the names dictionary or 'Not Found'
                                print(names.get(105,'Not Found'))








                  >>>>>>>>>>>>>Code Snippet: Dealing with Nested Data 


                                          # Print a list of keys from the boy_names dictionary
                      print(boy_names.keys())

                      # Print a list of keys from the boy_names dictionary for the year 2013
                      print(boy_names[2013].keys())

                      # Loop over the dictionary
                      for year in boy_names:
                          # Safely print the year and the third ranked name or 'Unknown'
                          print(year, boy_names[year].get(3,'Unknown'))   

         
         
         
  ----------------------------------Altering Dictionaries___________________________________________________
Dictionaries are mutable, so we can alter them in  number of ways
Adding and Extending Dictionaries
            - Assignment to add a new key/value to a dictionary
                              -You can add data to a dictionary just by using a new key as an index and assigning it a value 
                              -Also possible to supply a dictionary, list of tuples or a set of keywords arguments to the update()  method to add values into a dictionary
                                                  - .update() method to updaTE A DICTIONARY FROM ANOTHER DICTIONARY OR TUPLES OR KEYWORDS
                                                  
                              
                              
                              print(galleries_10007)    ### Have zipcode want to add
                              art_galleries['10007'] = galleries_10007    ### Assign zipcode as the key and then the dictionary as the value
                              
                              galleries_11234 = [("A J ARTS LTD', '(718) 763-5473'), ('Doug Meyer Fine Art", '(718) 375-8006')]   #### Can also create a list of tuples and supply them to the update() method
                              art_galleries['11234'].update(galleries_11234)   ### Supplying them to a dictionary index of the ziupcode since I want this data to be neted underneath it
                              
                              print(art_galleries['11234'])   ###Print the zipcode to be sure they wered added
            
         
         -Often we'll want to narrow the data to only the data which is relevant to the problem at hand, so let's lear how to remove data

Popping and deleting from dictionaries         
               - del instruction deletes a key?value  - however its important to remember that del will throw a KeyError if the key tyou're trying to delete doesn't exist
               - .pop() method safely removes a key/value froma dictionary 
         
                            - del art_galleries['11234']     ###let's start by removing all the galleries from zipcode '11234'
                            
                            galleries_10310 = art_galleries.pop('10310')        ### Not sure if there are any galleries in zipcode 10310, so I'm going to pop that zip code from the dictionary and save it
                            
                            
        Adding and extending dictionaries
If you have a dictionary and you want to add data to it, you can simply create a new key and assign the data you desire to it. It's important to remember that if it's a nested dictionary, then all the keys in the data path must exist, and each key in the path must be assigned individually.

You can also use the .update() method to update a dictionary with keys and values from another dictionary, tuples or keyword arguments. 
         
         
         
         
         
         
         >>>>>>>>>>>>>>>>> Code Snippet: Adding and Extending Dictionaries
         # Assign the names_2011 dictionary as the value to the 2011 key of boy_names
boy_names[2011] = names_2011

# Update the 2012 key in the boy_names dictionary
boy_names[2012].update(((1,'Casey'),(2,'Aiden')))

# Loop over the boy_names dictionary 
for year in boy_names:
    # Loop over and sort the data for each year by descending rank
    for rank in sorted(boy_names[year], reverse=True)[:1]:
        # Check that you have a rank
        if not rank:
            print(year, 'No Data Available')
        # Safely print the year and the least popular name or 'Not Available'
        print(year, boy_names[year].get(rank))
        
        
        
        Popping and deleting from dictionaries
Often, you will want to remove keys and value from a dictionary. You can do so using the del Python instruction. It's important to remember that del will throw a KeyError if the key you are trying to delete does not exist. You can not use it with the .get() method to safely delete items; however, it can be used with try: catch:.

If you want to save that deleted data into another variable for further processing, the .pop() dictionary method will do just that. You can supply a default value for .pop() much like you did for .get() to safely deal with missing keys. It's also typical to use .pop() instead of del since it is a safe method.

Here, you'll remove 2011 and 2015

>>>>>>>>>>>>>>>>>>Code Snippet
# Remove 2011 and store it: female_names_2011
female_names_2011 = female_names.pop(2011)

# Safely remove 2015 with an empty dictionary as the default: female_names_2015
female_names_2015 = female_names.pop(2015,{})

# Delete 2012
del female_names[2012]

# Print female_names
print(female_names)



        
        
-----------------------------------------------------Pythonically Using Dictionaries________________________________
 Previously we looped through dictionary keyts then used the keys to get the values we desired
 
          -   .items() method returns an object we can iterate over  ---   Python provides an items() method which returns a dict_items pobject but we can iterate over it as a list of key/value tuples
          
 If we use the .items()  metho on the original art_galleries dictionary it returns a tuple of the gallery name and then the phone number
        
         for gallery, phone_num in art_galleries.items():
                print(gallery)
                print(phone_num)
                
                
  I can use tuple unpacking to go ahead and expand that into its two components in the loop      
  Finally, I print them so you can see the information. 
  
  Now a more pythonic method for checking if the data is present in a dictionary 
  
  Checking Dictionairies for Data
            - earlier we ued the .get() method to safely check for keys and we can use that to check to see if a key is in a dictionary
            -python provides the in operator (which is much more efficient and clear) -- returns a boolean (True or False) 
                                                    -since returns a boolean, it is often used in conditionals statements like an if/else statement
  
  
                          '11234' in art_galleries        #Checks to see if key '11234' is in galleries
                          
                          
                          if '10010' in art_galleries : 
                                  print('I found: %s' % art_galleries['10010'])
                          else:
                                  print('No galleries found')
                          
     Working with dictionaries more pythonically
So far, you've worked a lot with the keys of a dictionary to access data, but in Python, the prefered manner for iterating over items in a dictionary is with the .items() method.

This returns each key and value from the dictionary as a tuple, which you can unpack in a for loop. You'll now get practice doing this.                     
         
 >>>>>>>>>>>Code Snippet: Working withj dictionaries more pythonically
 # Iterate over the 2014 nested dictionary
for rank, name in baby_names[2014].items():
    # Print rank and name
    print(rank, name)
    
# Iterate over the 2012 nested dictionary
for rank, name in baby_names[2012].items():
    print(rank, name)
    # Print rank and name
  
         
         
         
         
Checking dictionaries for data

You can check to see if a key exists in a dictionary by using the in expression.

For example, you can check to see if 'cookies' is a key in the dictionary by using if 'cookies' in recipes_dict: this allows you to safely react to data being present in the dictionary.

You can also use the in expression so see if data is in the value of a dictionary such as if 'cookies' in recipes_dict.values(). Remember you have to handle nested dictionaries differently as illustrated in the video and previous exercises, and use the in expression on each nested dictionary.         
         
         >>>>>>>>>>> Code Snippet
         # Check to see if 2011 is in baby_names
if '2011' in baby_names:
    # Print 'Found 2011'
    print('Found 2011')
    
# Check to see if rank 1 is in 2012
if 1 in baby_names[2012]:
    # Print 'Found Rank 1 in 2012' if found
    print('Found Rank 1 in 2012')
else:
    # Print 'Rank 1 missing from 2012' if not found
    print('Rank 1 missing from 2012')
    
# Check to see if Rank 5 is in 2013
if 5 in baby_names[2013]:
   # Print 'Found Rank 5'
   print('Found Rank 5')
   
   
------------------------------------------Working with CSV Files------------------------------------
Reading from a file using CSV reader

-Python csv module 
             - open() function provides a variable that represents a file, takes a path and a mode - 
                -To create a Python file object, you use the open() function, which accepts a name and a mode
                 - The mode is typically 'r' for read and 'w' for write
                 
              - then we pass the file object to the .reader() metho on the csv module and use it as you would any other iterable
                     csv.reader() reads a file object and returns the lines from the file as tuples
                     .close() method closes file objects
                     
              
              import csv                                      #import the csv module
              csvfile = open('ART_GALLERY.csv','r')              # create a fiule objects for the ART_GALLERY.csv data fiule
              for row in csv.reader(csvfile):                     # Then I use the csv.reader to read the file and iterate over each line or row in the file and print it
              
                      print(row)
              
                     
                     
   -python csv module also provides a way to directly create a dictionary from a csv file with the Dct Reader class
                  - often we want to go from csv file to dictionary
                  - DictReader does just that
                                        -if the file has a header row, that row will automaticcally be used as the keys for the dictionary
                  - If data doesn't have a header row, you can pass in the column names
                  - Eeach row of the file is returned as an OrderedDict object 
                  
                  -It's all the same until the line where we use the DictReader instead of the reaer method
                  -Then we print the row, we get an OrderedDict that looks like a list of tuples; however, it operates just like a normal dictionary
                  
                  
                      import csv
                      csvfile = open('ART_GALLERY.csv','r')
                      
                      for row in csv.DictReader(csvfile):
                              print(row)
   
                       csvfile.close()
       
       
       
 >>>>>>>>>>>>>> Code Snippet: Reading from a file using CSV reader
 Python provides a wonderful module called csv to work with CSV files. You can pass the .reader() method of csv a Python file object and use it as you would any other iterable. To create a Python file object, you use the open() function, which accepts a file name and a mode. The mode is typically 'r' for read or 'w' for write.

Though you won't use it for this exercise, often CSV files will have a header row with field names, and you will need to use slice notation such as [1:] to skip the header row
       
       # Import the python CSV module
import csv

# Create a python file object in read mode for the baby_names.csv file: csvfile
csvfile = open('baby_names.csv','r')

# Loop over a csv reader on the file object
for row in csv.reader(csvfile):
    # Print each row 
    print(row)
    # Add the rank and name to the dictionary
    baby_names[row[5]] = row[3]

# Print the dictionary keys
print(baby_names.keys())


>>>>>>>>>>>>>>> Code Snippet: Creating a dictionary from a file
The csv module also provides a way to directly create a dictionary from a CSV file with the DictReader class. If the file has a header row, that row will automatically be used as the keys for the dictionary. However, if not, you can supply a list of keys to be used. Each row from the file is returned as a dictionary. Using DictReader can make it much easier to read your code and understand what data is being used, especially when compared to the numbered indexes you used in the prior exercise.
# Import the python CSV module
import csv

# Create a python file object in read mode for the `baby_names.csv` file: csvfile
csvfile = open('baby_names.csv','r')

# Loop over a DictReader on the file
for row in csv.DictReader(csvfile):
    # Print each row 
    print(row)
    # Add the rank and name to the dictionary: baby_names
    baby_names[row['RANK']] = row['NAME']

# Print the dictionary keys
print(baby_names.keys())




------------------------------------- Counting Made Easy ________________________________
As data scientist, going to need to count items, create dictionary values before we know the keys to store them in, or maintain order in a dictionary 

Collections Module
    -Part of standard library
    -Advanced data containers
    
    
Counter - powerful python object based on the dictionary object that accepts a list and counts the number of times a values is found within the elements of that list
                -Special dictionary used for counting data, measruing frequency
                
                
                -Since it's dictionary based, can use all the normal dictionary features 
                

                        from collections import Counter
                        
                        nyc_eatery_count_by_types = Counter(nyc_eatery_types)   ### Here have a list named nyc_eatery_types that contains one column of data called type from a table about eateries in NYC parks
                                                                                 ### I create a new Conter based on that list and print it
                        print(nyc_eatery_count_by_type)          ### Can see each type from list ad the number of times it was found in the list
                         print(nyc_eatert_count_by_times['Restaurant'])                                        ### I can also see how many restaurants are in the counter by using Restaurant as the index and printing it
                                                                 

-Counters also provide a wonderful way to find the high values they contain
            -Counter t find the most common
                                  -  .most_common() method returns the counter values in descending order
                                              -returns a list of tuples containing the items and their count in descending order
                                  -great for frequency analytics,how often someting occurs            
                
                        print(nyc_eatery_count_by_types.most_common(3))  ###Here printing the top 3 eatery types in the NYC part system with the most_common method and passing t 3 as the numer of items to return
                                            

>>>>>>>>>>>>>>>>> Code Snippet: Using Counter on Lists
Counter is a powerful tool for counting, validating, and learning more about the elements within a dataset that is found in the collections module. You pass an iterable (list, set, tuple) or a dictionary to the Counter. You can also use the Counter object similarly to a dictionary with key/value assignment, for example counter[key] = value.

A common usage for Counter is checking data for consistency prior to using it, so let's do just that. In this exercise, you'll be using data from the Chicago Transit Authority on ridership.

       
       # Import the Counter object
from collections import Counter

# Print the first ten items from the stations list
print(stations[:10])

# Create a Counter of the stations list: station_count
station_count = Counter(stations)

# Print the station_count
print(station_count)




>>>>>>>>>>>>>>>>>>>>>>> Code Snippet: Finding the most common elements
Another powerful usage of Counter is finding the most common elements in a list. This can be done with the .most_common() method.

# Import the Counter object
from collections import Counter

# Create a Counter of the stations list: station_count
station_count = Counter(stations)

# Find the 5 most common elements
print(station_count.most_common(5))




--------------------------------------------------Dictionaries of unknown structures - Defaultdict _____________________________
Often will be working with data where we don't know all the keys that will be used but want to store a coplex structure under those keys

A good is example is I want every key to have a list of values
I' have to initialize every key with an empty list then asd the values to the list

Dictionary Handling - Ex (without Defaultdict)
      I can start by looping over a list of tuples with the park's d ad the name of the eatery
      
      for park_id, name in nyc_eateries_parks: 
              if park_id not in eateris_by_park:                   ### The can check to see if have a list for that aprt already in the dictionary
                      eateries_by_park[park_id] = []                ### If not then create an empty list
              eateries_by_park[park_id].append(name)                ### Next, append the name of the eatery to the list for that park id



Using defaultdict
            -Thankfully collections provides an easier way using defaultdict
                    -Pass it a default type tht every key will have even if it doesn't currently exist
                            -Defaultdict accepts a type that every value will default to if the key is not in present in the dictionary
                      - Works exactly like a dictionary
                               -You can overrude that type by setting the key manually to a value of a different type
                               
            -Still working with the nyc eatery, have a list of tuples that contain the park id and the name of an eatery 
            - I eant to create a list of eateries by park 
       
       
            from collections import defaultdict
            eateries_by_park = defaultdict(list)     ### Next, create a defaultdict that defaults to a list 
            
            for park_id, name in nyc_eateries_parks:          #### Next I iterae over my data and npack it into the park_id and name
               eateries_by_park[park_id].append(name)       #### I append each eatery name into list for each park_id
       
       
       It's also common to use a defaultdict as a type of counter for a list of dictionaries where we are counting ultiple keys from those dictionaries
                  In  our new york city eateries, curious as to how many had a published phone number or a website.
                  
                  
                  from collections import defaultdict
                  eatery_contact_types = defaultdict(int)   ### This time when creating my defaultdict, I tell it I ant it to be an int. 
                  
                  
                  for eatery in nyc_eateries:     
                      if eatery.get('phone'):
                              eatery_contact_types['phones'] += 1     #### Then I look over my nyc_eateries data and add 1 to the phones key if it has a phone number that is not None
                      if eatery.get('website'):
                               eatery_contact_types['websites'] += 1     #### Then I add one to the key if it has a websites
       
                  
               
  >>>>>>>>>>>>>>> Code Snippet: Creating dictionaries of an unknown structure
  
  # Create an empty dictionary: ridership
ridership = {}

# Iterate over the entries
for date, stop, riders in entries:
    # Check to see if date is already in the dictionary
    if date not in ridership:
        # Create an empty list for any missing date
        ridership[date] = []
    # Append the stop and riders as a tuple to the date keys list
    ridership[date].append((stop,riders))

    
# Print the ridership for '03/09/2016'
print(ridership['03/09/2016'])




>>>>>>>>>>>>>>>> Code Snippet: Safely appending to a key's value list 
Safely appending to a key's value list
Often when working with dictionaries, you know the data type you want to have each key be; however, some data types such as lists have to be initialized on
each key before you can append to that list.

A defaultdict allows you to define what each uninitialized key will contain. When establishing a defaultdict, you pass it the type you want it to be, such as a list, tuple, set, int, string, dictionary or any other valid type object.


# Import defaultdict
from collections import defaultdict

# Create a defaultdict with a default type of list: ridership
ridership = defaultdict(list)

# Iterate over the entries
for date, stop, riders in entries:
    # Use the stop as the key of ridership and append the riders to its value
    ridership[stop].append(riders)
    
# Print the first 10 items of the ridership dictionary
print(list(ridership.items())[:10])




----------------------Maintaining Dictionary Order with OrderDict-----------------------------------
Often we want to store data in the dictionary in an ordered fashion 
For example, I might want to store the data in order by date, or by a ranking

Order in Python Dictionaries
      -Normal dictionaries don't maintain order of the keys hat you insert into them before Python 3.6
          Python version > 3.6 ordered
          
          
       However, the collections module provides an OrderedDict that maintains the order that keys and values as they were added to the dictionary without regard for the Python version
       You might remember this from our video usi g the CSV dictreader whch returned each row as an OrderedDict
       
       
Getting Started with OrderedDict
       
       
       
       from collections import OrderedDict
       
       nyc_eatery_permits = OrderedDict()   ### Next I create an OrderedDict to hold the NYC park data by permit end date
       
       for eatery in nyc_eateries:     ### Then I loop over the NYC park eateries which are ordered by permit end date already and add them to the OrderedDict by that date
              nyc_eatery_permits[eatert['end_date']] = eatery
       print(list(nyc_eatery_permits.items())[:3]      ###Finally I can print the first 3 permit end dates by making a list of the items and slicing it
       
       
 OrderedDict power feature
        .popitem() method returns items in reverse insertion order
        
                        print(nyc_eatery_permits.popitems())     ###using the OrderedDict from previous examples, I use popitem() and get the permit that expires the latest, a second popitem() retrns the next latest experiation
                        
         Finallt I can pop the lowest end date in the dictionary by using popitem(last=False) here               
                You can use the last=FALSE keyword argument o return the items in insertion order       
       
       
      
                        print(yc_eatery_permits.popitem(last=FALSE))



  
>>>>>>>>>>>>>>>>>>>>>>Code Snippet:  Working with OrderedDictionaries
Recently in Python 3.6, dictionaries were made to maintain the order in which the keys were inserted; however, in all versions prior to that you need to use an OrderedDict to maintain insertion order.


# Import OrderedDict from collections
from collections import OrderedDict

# Create an OrderedDict called: ridership_date
ridership_date = OrderedDict()

# Iterate over the entries
for date, riders in entries:
    # If a key does not exist in ridership_date, set it to 0
    if not date in ridership_date:
        ridership_date[date] = 0
        
    # Add riders to the date key in ridership_date
    ridership_date[date] += riders
    
# Print the first 31 records
print(list(ridership_date.items())[:31])







>>>>>>>>>>>>>>>>>> Code Snippet: Powerful Ordered popping
Where OrderedDicts really shine is when you need to access the data in the dictionary in the order you added it. OrderedDict has a .popitem() method that will return items in reverse of which they were inserted. You can also pass .popitem() the last=False keyword argument and go through the items in the order of how they were added.


# Print the first key in ridership_date
print(list(ridership_date.keys())[0])

# Pop the first item from ridership_date and print it


print(ridership_date.popitem(last=False))

# Print the last key in ridership_date
print(list(ridership_date.keys())[-1])

# Pop the last item from ridership_date and print it
print(ridership_date.popitem())



--------------------------------------------------------------------------What do you mean I don't have class? 
Namedtuple----------------------------------------------------------------

Often times when working with data you'll use a dictionary in order to use ky names to make reading the code and accessing the data easier to understand.
Python has another container called a namedtuple which is tuple, but has names for each position of the tuple 
            - A tuple where each positon (column) has a name
            -Ensure each one has the same properties       
                   -This works well when you don't ned the nested structure of a dictionary or desire each items to look identical 
            -Alternative to a pandas DataFrame row
            
            
 Creating a named tuple
              -Pass a name and a list of field names - in order to create a namedtuple
              -Let's begin by importing namedtuple from the collections module 
              
              
              from collections import namedtuple
              
              Eatery = namedtuple('Eatery',['name,'location','park_id','type_name'])                ###Next we'll define our namedtuple; common practice to use Pascalcase (capitalizing each word) when naming namedtuples so here I've used Eatery with a capital Efor both the tuple name and the variable we stored the namedtuple as
                                                                                                     ### Then we provide a list of fields we want on the namedtuple
                                                                                                      ### Going to change NYC Park eateries data into a list of namdtuples
              for eatery in nyc_eateries:
                    details = Eatery( eatery['name'],
                                      eatery['locaion'],                       #### Create an empty list then itrate over my nyc_eatries list creating an instance of my 
                                      eatery['park_id'],                       #### Eatery namedtuple by passing in the data from the loop as the arguments to my namedtuple
                                      eatery['type_name'])
                    eateries.append(details)                  
              
              
              print(eateries[0])                              #### Finally let's print the first Eatery in the list 
              
              
 Leveraging namedtuples
                    - Each field available as an attriubte of the namedtuple - can make code much cleaner
                                  -Attribute is basically a named field or data storage location
                                  
                                  -We can also depend on every isntance of a namedtuple to have all the fields although some might be empty or None in Python terms
                                            -This means we can aleays have safe access to a field without the need for a get method like a dictionary
                     -Going to use the list of tuples from the prior slides and pritn the name, park_id, location for the first three entries in the list
                          
                                   for eatery in eateries[:3]:
                                              print(eatery.name)
                                              print(eatery.park_id)
                                              print(eatery.location)
                                              
                                              
   
   
>>>>>>>>>>>>> Code Snippet: Creating namedtuples for storing data
Often times when working with data, you will use a dictionary just so you can use key names to make reading the code and accessing the data easier to understand. Python has another container called a namedtuple that is a tuple, but has names for each position of the tuple. You create one by passing a name for the tuple type and a list of field names.

For example, Cookie = namedtuple("Cookie", ['name', 'quantity']) will create a container, and you can create new ones of the type using Cookie('chocolate chip', 1) where you can access the name using the name attribute, and then get the quantity using the quantity attribute.

# Import namedtuple from collections
from collections import namedtuple

# Create the namedtuple: DateDetails
DateDetails = namedtuple('DateDetails', ['date', 'stop', 'riders'])

# Create the empty list: labeled_entries
labeled_entries = []

# Iterate over the entries
for date, stop, riders in entries:
    # Append a new DateDetails namedtuple instance for each entry to labeled_entries
    details = DateDetails(date,stop,riders)
    labeled_entries.append(details)
    
# Print the first 5 items in labeled_entries
print(labeled_entries[:5])




            
            
---------------------------------------------There and Back Again a DateTime JOurney--------------------------------
Will be using data from NYC parking violations data

From string to datetime
     -The datetime module is part of the Standard Python library
                        When working with datetimes in Python we use the datetime module from the standard library
     -Use the datetime type from inside the datetime module
                        There is a dateti,e type inside of the datetime module
     - .strptime() converts from a string to a datetime object
                          In addition to letting us manually create datetime objects, we can also parse existing strings into datetime objects
                          
                          
                          
      from datetime import datetime
      print(parking_violations_date)                                    ###Next I'm printing th string that we are going to parse to create a datetime object
      date_dt = datetime.strptime(parking_violations_date, '%m/%d/%Y')          ###Next I use the strptime method to parse the parking violations date using a format string for MM/DD/YYYY (more on this in just one case)
      print(date_dt)                              ### Finally I print the datetime object so we can see the results
      
      
     
Tikme Format Strings
              Time format strings are so common across many different programming kanguages and originated in C
              You csn use the directives and any special caracters or spacs you need to match the datestring you are trying to parse
              In additions to using these to convert from a datetime to a string object with the strftime() method


Datetime to String
            - .strftime() method uses a format string to convert a datetime object to a string
                                 For example we can use the same format string to output the date time we created on a prior slide
                                 
                                 date_dt.strftime('%m/%d/%Y')
                                 
                                 
            -.isoformat() methd outputs a datetime as an ISO standard string, one of the mmost common ways to express times when dealing with writing to or readijng from files or applications
                                  date_dt.isoformat()           #Let's use it on our datetime object we've been working with
                              
>>>>>>>>>>>> Code Snippet: Strings to DateTimes
Time to begin your DateTime journey! You'll start by using the .strptime() method from the datetime object as shown in the video, passing it both the string and the format

# Import the datetime object from datetime
from datetime import datetime

# Iterate over the dates_list 
for date_str in dates_list:
    # Convert each date to a datetime object: date_dt
    date_dt = datetime.strptime(date_str,'%m/%d/%Y')
    
    # Print each date_dt
    print(date_dt)



>>>>>>>>>>>>>>>Code Snippet: Converting to a String
Converting from a datetime object to a string is done with the .strftime() method on a instance of the datetime object. You pass a format string just like the ones used in the prior exercise.

There is also a widely used string output standard called ISO-8601. It has a shortcut method named .isoformat(). I encourage you to use it anytime you write out to a file.

# Loop over the first 10 items of the datetimes_list
for item in datetimes_list[:10]:
    # Print out the record as a string in the format of 'MM/DD/YYYY'
    print(item.strftime('%m/%d/%Y'))
    
    # Print out the record as an ISO standard string
    print(item.isoformat())
    
    
    
    ____________________________________________ Working with Datetime Components and current time______________________

Once we have a datetime object, we can work with it to get  parts of the datetime like the month, year, day
We can also get the current time and maniuplate a timezone 

Datetime Components
       All parts of a datetimeobject are available as attributes
                      day, month, year, hour, minute, seconds and more are available from a datetime instance 

        Great for grouping data
        
        
        
        >>> daily_violations = defaultdict(int)      ### we'll start by using a defaultdict of ints to count the records
        for violation in parking_violations:        ### Next I'll loop over the parking violations to and parse the date which is found in the 5th element of our list
                violation_date = datetime.strptime(violation[4], '%m/%d/%y')
                
                daily_violations[violation_date.day] += 1
                
         print(sorted(daily_violations.items()))   ###Finally sort the days of the month and print the day of the month and our violation count for that day
         
         
         Often when working with datetime objects, you'll want to work on windows or ranges that start from the current date and time  
         
         What is the deal now?
                  We can do this using the .now() method on the datetime object in the datetime module and a .utcnow() method
                  
                  .now() method reutrns the current local datetime - returns the current local time on the machine on which it is run
                  .utcnow() method returns the current UTC datetime - does the same but returns it in utc timezone
                  
                                            

                                  >>> from datetime import datetime
                                  local_dt = datetime.now()
                                  print(local_dt)
                                  
                                  
                                  >>> utc_dt = datetime.utcnow()
                                  
Timezones
          Naive datetime objects havew no timezone data - By default, any datetime you make using the now methods are "naive" datetime objects, whcih means they are missing their timezone that is required to make an "aware" of datetime object. 
          Aware datetime objects have a timezone - will often get data where there is no timezone and will need to set it manually 
                      In order to work effectively
                      
           Timezone data is available via the pytz module via the timezone object 
                        and use the timezone names from the Olsen database, the standard for timezone information
                        
           Aware objects have a .astimezone() so you can get the time in another timezone 
                      -an aware object has a .astimezone() that accepts a timezone object and returns a new datetime object in the desired timezone
                      



            If the tzinfo isn't set for the datetime object it assumes the timezone of the computer you are working on
            


Timezones in Action
        
            from pytz import timezone
            
            record_dt = datetime.strptime('07/12/2016 04:39PM', '%m/%d/%Y %H:%M%p')   ### I've got the datetime of a violation and parsed it into a naive datetime object
         
            ### Next going to prepare the timezone objects I'm going to work with
            ### The create an object to present the Eastern timezoen that NYC is in and then the timezone for LA
               ny_tz = timezone('US/Eastern')
               la_tz = timezone('US/Pacific')
               ny_dt = record_dt.replace(tzinfo=ny_tz)   ### Next use the replace method to replace the empty timezone on my record datetime and save it as my datetinme
               la_dt  = ny_dt.astimezone(la_tz) ###Now that I have an aware datetime instance, I can use the as timezone method to get the records time in la
               
               ###This type of conversion is greart for ensuring that data remains relevant to the viewere by presenting it in their mative timezone
               



>>>>>>>>>>> Code Snippet: Pieces of Time
When working with datetime objects, you'll often want to group them by some component of the datetime such as the month, year, day, etc. Each of these are available as attributes on an instance of a datetime object.

You're going to work with the summary of the CTA's daily ridership. It contains the following columns, in order: service_date, day_type, bus, rail_boardings, and total_rides. The modules defaultdict and datetime have already been imported for you.

Instructions:
Create a defaultdict of an integer called monthly_total_rides.
Loop over the list daily_summaries, which contains the columns mentioned above in the assignment text.
Convert the service_date (1st element of daily_summary) to a datetime object called service_datetime. Use '%m/%d/%Y' as your format string.
Use the month of the service_datetime as the dict key and add the total_rides (5th element of daily_summary) to the current amount for the month. Be sure to convert this into an integer.
Print monthly_total_rides.


# Create a defaultdict of an integer: monthly_total_rides
monthly_total_rides = defaultdict(int)

# Loop over the list daily_summaries
for daily_summary in daily_summaries:
    # Convert the service_date to a datetime object
    service_datetime = datetime.strptime(daily_summary[0],'%m/%d/%Y')

    # Add the total rides to the current amount for the month
    monthly_total_rides[service_datetime.month] += int(daily_summary[4])
    
# Print monthly_total_rides
print(monthly_total_rides)





>>>>>>> Code Sippet: Creating Datetime Objects.....Now
Often when working with datetime objects, you'll want to work on windows or ranges that start from the current date and time. You can do this using the datetime now functions. There is a .now() method on the datetime object in the datetime module and a .utcnow() method. The .now() method returns the current local time on the machine on which it is run, and .utcnow() does the same thing but returns the value in UTC time. You'll need to be very familiar with these methods.

# Import datetime from the datetime module
from datetime ikport datetime

# Compute the local datetime: local_dt
local_dt = datetime.now()

# Print the local datetime
print(local_dt)

# Compute the UTC datetime: utc_dt
utc_dt = datetime.utcnow()

# Print the UTC datetime
print(utc_dt)



>>>>>>>>>>> Code Snippet:
Timezones
In order to work effectively with other timezones, you can use the pytz library. To use timezones, you need to import the timezone object from the pytz module. Then you can use the timezone constructor and pass it a name of a timezone, such as CT = timezone('US/Central'). You can get a full list of timezone names at Wikipedia. In Python 3, you can make a datetime object "aware" by passing a timezone as the tzinfo keyword argument to the .replace() method on a datetime instance.

An "aware" datetime object has an .astimezone() method that accepts a timezone object and returns a new datetime object in the desired timezone. If the tzinfo is not set for the datetime object it assumes the timezone of the computer you are working on.

A list, daily_summaries, has been supplied for you it contains the datetime and rail ridership for trains going to New York. You need to determine the time in New York so you can align it with the New York Transit Authority data.

Instructions:
              Create a Timezone object for Chicago ('US/Central') called chicago_usa_tz.
              Create a Timezone object for New York ('US/Eastern') called ny_usa_tz.
              Iterate over the daily_summaries, unpacking it into the variables orig_dt and ridership.
              Make the orig_dt timezone "aware" for Chicago, using chicago_usa_tz. Store the result in chicago_dt.
              Convert chicago_dt to the New York timezone, ny_dt.
              Print the chicago_dt, ny_dt, and ridership.




# Create a Timezone object for Chicago
chicago_usa_tz = timezone('US/Central')

# Create a Timezone object for New York
ny_usa_tz = timezone('US/Eastern')

# Iterate over the daily_summaries list
for orig_dt, ridership in daily_summaries:

    # Make the orig_dt timezone "aware" for Chicago
    chicago_dt = orig_dt.replace(tzinfo=chicago_usa_tz)
    
    # Convert chicago_dt to the New York Timezone
    ny_dt = chicago_dt.astimezone(ny_usa_tz)
    
    # Print the chicago_dt, ny_dt, and ridership
    print('Chicago: %s, NY: %s, Ridership: %s' % (chicago_dt, ny_dt, ridership))
    
    
    
    ___________________________________________________Time Travel (Adding and Subtracting Time)_______________________
A very common case when working with times is to get a date 30,60,90 days in the past from some date

Incrementing through time 
        - A very common case when working wih times is to get a date 30, 60, 90 days in the past from some date
        -timedelta is used to represent an amount of change in time
        -used to add or subtract a set amont of time from a datetime object
                -in python we use the timedelta object from the datetime module to represent differences in datetime objects
                -you can ceate a timedelta by passing nay number of keyword arguments such as days, seconds, microsecnds, milliseconds, minutes, hours and weeks to it
        -Once we have a timedelta object, we can add or subtract it from a datetime object to get a datetime object relative to the original datetime object


                        from datetime import timedelta
                        flashback = timedelta(days=90)    ###Next we'll make a timedelta instance called flashback for 90 days
                        print(recod_dt)                   ### Then e can see the starting point by printing the datetime we'll be working with
                        print(record_dt - flashback)      ###then print the date minus 90 days and finally plus 90 days
                        print(record_dt + flashback)     ### This can be useful to compare a date this year to one from the prior year, compare  by quarter as we did here, or compare month to month

         -Just like we were able to sibtract a timedelta from a datetime to find a date in the past, we can also calculate the difference between two dates to get the timedelta between in return
         -Let's find out how much time has elapsed between the first two violations in our list
 
 
 Datetime differences
 
      -Use the - operator to calculate the difference
      -Returns a timedelta with the difference
              ###I've already parsed both date unto record_dt and record_dt2 respectively. 
      
                        time_diff = recod_dt - record2_dt  ###Now subtract one from the other and store the result as time_diff
                        type(time_dff)   ### This will return a timedelta, that represents the time difference between the two datetimes
                        print(time_diff)   ### Finally I can print the time_diff and see that time difference btween violations was 4 seconds
                        
                        
        
                
Code Snippet >>>>>>>>>>>>>>>>>> 
Finding a time in the future and from the past


Another common case when working with times is to get a date 30, 60, or 90 days in the past from some date. In Python, the timedelta object from the datetime module is used to represent differences in datetime objects. You can create a timedelta by passing any number of keyword arguments such as days, seconds, microseconds, milliseconds, minutes, hours, and weeks to timedelta().

Once you have a timedelta object, you can add or subtract it from a datetime object to get a datetime object relative to the original datetime object.

A dictionary, daily_summaries, has been supplied for you. It contains the datetime as the key with a dict as the value that has 'day_type' and 'total_ridership' keys. A list of datetimes to review called review_dates is also available.


# Import timedelta from the datetime module
from datetime import timedelta

# Build a timedelta of 30 days: glanceback
glanceback = timedelta(days=30)

# Iterate over the review_dates as date
for date in review_dates:
    # Calculate the date 30 days back: prior_period_dt
    prior_period_dt = date - glanceback
    
    # Print the review_date, day_type and total_ridership
    print('Date: %s, Type: %s, Total Ridership: %s' %
         (date, 
          daily_summaries[date]['day_type'], 
          daily_summaries[date]['total_ridership']))

    # Print the prior_period_dt, day_type and total_ridership
    print('Date: %s, Type: %s, Total Ridership: %s' %
         (prior_period_dt, 
          daily_summaries[prior_period_dt]['day_type'], 
          daily_summaries[prior_period_dt]['total_ridership']))
          
          
   Code Snppet >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Finding differences in DateTimes
Just like you were able to subtract a timedelta from a datetime to find a date in the past, you can also calculate the difference between two dates to get the timedelta between in return. Here, you'll find out how much time has elapsed between two transit dates.

A list of tuples called date_ranges is provided for you. We took the dates from our dataset at every 30th record, and we paired up the records into tuples in a stepwise fashion

       # Iterate over the date_ranges
for start_date, end_date in date_ranges:
    # Print the End and Start Date
    print(end_date, start_date)
    # Print the difference between each end and start date
    print(end_date - start_date)



_______________________________________________Libraries Make It Easier_____________________________________________
There are several 3rd party libraries that make parsing, converting, and working with dates and times easier. 

Parsing time with Pendulum 
        -One of the most popular is the Pendulum library. 
                - .parse() will attempt to convert a stirng to a pendulum datetime object without the need of the format string
                -Just pass it a date string and it will attempt to convert into a valid pendulum datetime 
                
                ### Example of how helpful a parse can be
                
                import pendulum
                occurrred = violation[4] + ' ' + violation[5] + 'M'   ###Using the first parking violation, bulding a tring called occurred that is the date plus a space plus the time and appending an M to complete the AM/PM indicator 
                occurred_dt = pendulum.parse(occurred, tz='US/Eastern')  ### Then I use pendulum .parse() on the string and instruct pendulum that it's in the Eastern timezone all on one line
                print(occurred_dt)              ### Finally I print the date that pendulum parsed - Note that they use an aware version of the ISO standard string 
                                          ### If we were to do this with datetim we'd need to use strptime =w/ a format string and use the replace method to fix the timezone
                                          
                
                
Timezone Hopping with Pendulum
              - Pendulum has wonderful support for timezones and comes with the Olsen Database built into it
              - .in_timzeon() method converts a pendulum time object to a desired timezone
              - .now() method accepts a timezone you want to get the current time in (to generate the current time easily for any location in the world)
              - I saved the results for our pendulum parsin example into the violations_dts list as you can see here
              
               ### I'm going to iterate over the records and convert them all to Tokyo timezone
               for violation_dt in violation_dts:
                      print(violation_dt.in_timzeone('Asia/Tokyo')
                                                                        ### Finally I'm going to ue the now() method with the Tokyo timezone to ge the current time in Tokyo
               print(pendulum.now('Asia/Tokyo')


Humanizing Differences
        -Pendulum has an alternative to timedeleta called a period when calculating the difference betwee two dates by subtraction that provides methods such as dot in_days/weeks/hour/minutes and in_words to poutput in a chose manner
                  - .in_xxx() methods provide the differene in a chosementric
                  - .in_words() provides the difference in a nice expressive form
                  
        ### Example 
                  dif = violation_dts[3] - violation_dts[2]
                  print(diff.inwords())   ### Next I use the in_words() method to get a nice english representation of the difference
                  print(diff.in_days())    ###The I use the in_days method to see the difference in days and the in_hours to see the difference in hours
                  print(diff.in_hours())
       -Pendulum provides the ability to set a local and get it in other langages
       

Code Snippet >>>>>>>>>>>>>>>> Localizing time with pendulum
Import the pendulum module.
Create a now datetime for Tokyo ('Asia/Tokyo') called tokyo_dt.
Covert tokyo_dt to Los Angeles time ('America/Los_Angeles'). Store the result as la_dt.
Print the ISO 8601 string of la_dt, using the .to_iso8601_string() method.

# Import the pendulum module
import pendulum

# Create a now datetime for Tokyo: tokyo_dt
tokyo_dt = pendulum.now('Asia/Tokyo')

# Covert the tokyo_dt to Los Angeles: la_dt
la_dt = tokyo_dt.in_timezone('America/Los_Angeles')

# Print the ISO 8601 string of la_dt
print(la_dt.to_iso8601_string())


>>>>>>>>>>>>>>> Code Snippet: Humanizing Differences with Pendulum
Pendulum provides a powerful way to convert strings to pendulum datetime objects via the .parse() method. Just pass it a date string and it will attempt to convert into a valid pendulum datetime. By default, .parse() can process dates in ISO 8601 format. To allow it to parse other date formats, pass strict = False.

It also has a wonderful alternative to timedelta. When calculating the difference between two dates by subtraction, pendulum provides methods such as .in_days() to output the difference in a chosen metric. These are just the beginning of what pendulum can do for you.

A list of tuples called date_ranges is provided for you. This is the same list of tuples that contain two dates that was used a few exercises prior. You'll be focusing on comparing ranges of records.

You can learn more in the pendulum documentation. Here, it has been imported for you.


# Iterate over date_ranges
for start_date, end_date in date_ranges:

    # Convert the start_date string to a pendulum date: start_dt 
    start_dt = pendulum.parse(start_date, strict=False)
    
    # Convert the end_date string to a pendulum date: end_dt 
    end_dt = pendulum.parse(end_date, strict=False)
    
    # Print the End and Start Date
    print(end_dt, start_dt)
    
    
    
    
    
    -----------------------------------------------------------Counting Within Date Ranges ------------------------------------------
    Chicago Crimes
    
    Part 1- Step 1 - Begin case study by reading ata from a CSV and building a list to hold your data
    
                Ex:    import csv
                       csvfile = open('ART_GALLERY','r')
                       for row in csv.reader(csvfile): 
                              print(row)

            Step 2 - You'll count the data by month using a counter similarly to how we did previously
               
               Ex:    from collections import Countr
                      nyc_eatery_count_by_types = Counter(nyc_eatery_types)

                 Use date parts for grouping like in Chapter 4; use the month date part to group/count the ddata by month
                
               Ex: daily_violations = defaultdict(int)
                   for violation in parking_violations:
                          violation_date = datetime.strptime(violation[4], '%m/'%d/%Y')
                          daily_violations[violation_date.day] += 1
               In date part grouping example we used a defaultdict but for this problem will be using a counter
               

Step 3 - Next we want to extract the data into a dicitonary keys by month that stores a list of te location types where the crimes occurred that month
We'll use the defaultdict we leaerned about coupled with the date component grouping we just used in the prior step and learned earlier

-Group data by Month
-The date components we learned about earlier

Final - So to answer the real question, "What are the five most common crime locations per month?"
We'll use a Counter on our new dictionary as we did previous to find the answer we're looking for

-Find 5 most common locations for crime each month

print(nyc_eatery_count_by_types.most_common(3))




            
--------------------------------------------------------------------Final Section --------------------------------------------
Reading your data with CSV Reader and Establishing your Data Containers
Let's get started! The exercises in this chapter are intentionally more challenging, to give you a chance to really solidify your knowledge. Don't lose heart if you find yourself stuck; think back to the concepts you've learned in previous chapters and how you can apply them to this crime dataset. Good luck!

Your data file, crime_sampler.csv contains the date (1st column), block where it occurred (2nd column), primary type of the crime (3rd), description of the crime (4th), description of the location (5th), if an arrest was made (6th), was it a domestic case (7th), and city district (8th).

Here, however, you'll focus only 4 columns: The date, type of crime, location, and whether or not the crime resulted in an arrest.

Your job in this exercise is to use a CSV Reader to load up a list to hold the data you're going to analyze.

INSTRUCTIONS
100 XP
INSTRUCTIONS
100 XP
Import the Python csv module.
Create a Python file object in read mode for crime_sampler.csv called csvfile.
Create an empty list called crime_data.
Loop over a csv reader on the file object :
Inside the loop, append the date (first element), type of crime (third element), location description (fifth element), and arrest (sixth element) to the crime_data list.
Remove the first element (headers) from the crime_data list.
Print the first 10 records of the crime_data list. This has been done for you, so hit 'Submit Answer' to see the result!


>>>>>>>>>>>>>>>>>Code:
# Import the csv module
import csv

# Create the file object: csvfile
csvfile = open('crime_sampler.csv','r')

# Create an empty list: crime_data
crime_data = []

# Loop over a csv reader on the file object
for row in csv.reader(csvfile):

    # Append the date, type of crime, location description, and arrest
    crime_data.append((row[0], row[2], row[4], row[5]))
    
# Remove the first element from crime_data
crime_data.pop(0)

# Print the first 10 records
print(crime_data[:10])



------------------------------------------------------------------------

Find the Months with the Highest Number of Crimes
Using the crime_data list from the prior exercise, you'll answer a common question that arises when dealing with crime data: How many crimes are committed each month?

Feel free to use the IPython Shell to explore the crime_data list - it has been pre-loaded for you. For example, crime_data[0][0] will show you the first column of the first row which, in this case, is the date and time time that the crime occurred.

INSTRUCTIONS
100 XP
Import Counter from collections and datetime from datetime.
Create a Counter object called crimes_by_month.
Loop over the crime_data list:
Using the datetime.strptime() function, convert the first element of each item into a Python Datetime Object called date.
Increment the counter for the month associated with this row by one. You can access the month of date using date.month.
Print the 3 most common months for crime.


>>>>>>>>>>>>>>> Code Snippet: 
# Import necessary modules
from collections import Counter
from datetime import datetime

# Create a Counter Object: crimes_by_month
crimes_by_month = Counter()

# Loop over the crime_data list
for row in crime_data:
    
    # Convert the first element of each item into a Python Datetime Object: date
    date = datetime.strptime(row[0], '%m/%d/%Y %I:%M:%S %p')
    
    # Increment the counter for the month of the row by one
    crimes_by_month[date.month] += 1
    
# Print the 3 most common months for crime
print(crimes_by_month.most_common(3))



____________________________________________________________________________________________________________________
Transforming your Data Containers to Month and Location
Now let's flip your crime_data list into a dictionary keyed by month with a list of location values for each month, and filter down to the records for the year 2016. Remember you can use the shell to look at the crime_data list, such as crime_data[1][4] to see the location of the crime in the second item of the list (since lists start at 0).

INSTRUCTIONS
100 XP
INSTRUCTIONS
100 XP
Import defaultdict from collections and datetime from datetime.
Create a dictionary that defaults to a list called locations_by_month.
Loop over the crime_data list:
Convert the first element to a date object exactly like you did in the previous exercise.
If the year is 2016, set the key of locations_by_month to be the month of date and append the location (fifth element of row) to the values list.
Print the dictionary. This has been done for you, so hit 'Submit Answer' to see the result!


>>>>>>>>> Code Snippet:
# Import necessary modules
from collections import defaultdict
from datetime import datetime


# Create a dictionary that defaults to a list: locations_by_month
locations_by_month = defaultdict(list)

# Loop over the crime_data list
for row in crime_data:
    # Convert the first element to a date object
    date = datetime.strptime(row[0], '%m/%d/%Y %I:%M:%S %p')
    
    # If the year is 2016 
    if date.year == 2016:
        # Set the dictionary key to the month and add the location (fifth element) to the values list
        locations_by_month[date.month].append(row[4])
    
# Print the dictionary
print(locations_by_month)



______________________________________________________________________________________________________________________________

Find the Most Common Crimes by Location Type by Month in 2016
Using the locations_by_month dictionary from the prior exercise, you'll now determine common crimes by month and location type. Because your dataset is so large, it's a good idea to use Counter to look at an aspect of it in an easier to manageable size and learn more about it.



Import Counter from collections.
Loop over the items from your dictionary, using tuple expansion to unpack locations_by_month.items() into month and locations.
Make a Counter of the locations called location_count.
Print the month.
Print the five most common crime locations.


>>>>>>>>>>>>>>>>>> Code Snippet:

# Import Counter from collections
from collections import Counter

# Loop over the items from locations_by_month using tuple expansion of the month and locations
for month, locations in locations_by_month.items():
    # Make a Counter of the locations
    location_count = Counter(locations)
    # Print the month 
    print(month)
    # Print the most common location
    print(location_count.most_common(5))
    
    
    

_________________________ Case Study - Crimes by District and Differences by Block________________________________________

First, going to determine how many crimes occurred by district, and thn look at how many types of crimes differ between city blocks


Part 2 - Step 2 
Previously we read the data directly from the csv file into a dictionary as shown here
You'll need to determine how to properly build the dictionary based on the assignment instructions

-Read in the CSV data as a dictionary 
            import csv
            csvfile = opem('ART_GALLERY.cv','r')
            for row in csv.DictReader(csvfile):   ###This example shows how to use the dictreader which gives you a dictionary per row of the file
                  print(row)
      
-Pop out the key and store the remaining dict
### Then we can use that dictionary to do things like pop out a key, as we did in a prpr exercises and store the remainder of that data under that key in another dictionary
Here is a reminder of how to pop data from a dictionary, which leaves the original dctionary with everything but that key and value still in place

            galleries_10310 = art_galleries.pop('100310')


Part 2  - Step 2
        -Pythonically iterate over the Dictionary
                The we want to determine how many crimes occurred by district
                You'll need to loop over the dictionary pythonically and the use Counter and defaultdict as we have several times in this case study
                Here is an example of how we Pythonically looped over dictionaries in our videos
                
                        for zip_code, galleries in art_galleries.items():
                                print(zip_code)
                                print(galleries)

                
                
Wrapm- Up
In this last stop of our case study, weve identified a few blocks of data we want to concentrate on and see the differenes in cries that occur in these locations.

-Use Sets for uniqueness
          -First you'll want to take a list and get a unique set of crimes for that block as we did in chapter one
          
                      cookies_eaten_today = ['chocolate chip', 'peanut butter', 'chocolate chip', 'oatmeal cream', 'chocolate chip']
                      types_of_cookies_eaten = set(cookies_eaten_toay)
                      print(types_of_cookies_eaten)
                      
-difference() set method as at the end of Chapter 1
        -Then you'll look for diffrence in the unique crime sets
        
        
                      cookies_jason_ate.difference(cookies_hugo_ate)
                      
                      
  ________________________________________________________________________________________________________________________________
 Reading your Data with DictReader and Establishing your Data Containers
Your data file, crime_sampler.csv contains in positional order: the date, block where it occurred, primary type of the crime, description of the crime, description of the location, if an arrest was made, was it a domestic case, and city district.

You'll now use a DictReader to load up a dictionary to hold your data with the district as the key and the rest of the data in a list. The csv, defaultdict, and datetime modules have already been imported for you.

Create a Python file object in read mode for crime_sampler.csv called csvfile.
Create a dictionary that defaults to a list called crimes_by_district.
Loop over a DictReader of the CSV file:
Pop 'District' from each row and store it as district.
Append the rest of the data (row) to the district key of crimes_by_district.

>>>>>>>>>>>>>> Code Snippet:
# Create the CSV file: csvfile
csvfile = open('crime_sampler.csv','r')

# Create a dictionary that defaults to a list: crimes_by_district
crimes_by_district = defaultdict(list)

# Loop over a DictReader of the CSV file
for row in csv.DictReader(csvfile):
    # Pop the district from each row: district
    district = row.pop('District')
    # Append the rest of the data to the list for proper district in crimes_by_district
    crimes_by_district[district].append(row)



_____________________________________________________________________________________________________________
Determine the Arrests by District by Year
Using your crimes_by_district dictionary from the previous exercise, you'll now determine the number arrests in each City district for each year. Counter is already imported for you. You'll want to use the IPython Shell to explore the crimes_by_district dictionary to determine how to check if an arrest was made.

INSTRUCTIONS
100 XP
Loop over the crimes_by_district dictionary, unpacking it into the variables district and crimes.
Create an empty Counter object called year_count.
Loop over the crimes:
If there was an arrest,
Convert crime['Date'] to a datetime object called year.
Add the crime to the Counter for the year, by using year as the key of year_count.
Print the Counter. This has been done for you, so hit 'Submit Answer' to see the result!


>>>>>>>>>>>>>> Code Snippet:
# Loop over the crimes_by_district using expansion as district and crimes
for district, crimes in crimes_by_district.items():
    # Print the district
    print(district)
    
    # Create an empty Counter object: year_count
    year_count = Counter()
    
    # Loop over the crimes:
    for crime in crimes:
        # If there was an arrest
        if crime['Arrest'] == 'true':
            # Convert the Date to a datetime and get the year
            year = datetime.strptime(crime['Date'], '%m/%d/%Y %I:%M:%S %p').year
            # Increment the Counter for the year
            year_count[year] += 1
            
    # Print the counter
    print(year_count)
    
    
    ________________________________________________________________________________________________________________________
    Unique Crimes by City Block
You're in the home stretch!

Here, your data has been reshaped into a dictionary called crimes_by_block in which crimes are listed by city block. Your task in this exercise is to get a unique list of crimes that have occurred on a couple of the blocks that have been selected for you to learn more about. You might remember that you used set() to solve problems like this in Chapter 1.

Go for it!

Create a unique list of crimes for the '001XX N STATE ST' block called n_state_st_crimes and print it.
Create a unique list of crimes for the '0000X W TERMINAL ST' block called w_terminal_st_crimes and print it.
Find the crimes committed on 001XX N STATE ST but not 0000X W TERMINAL ST. Store the result as crime_differences and print it.


# Create a unique list of crimes for the first block: n_state_st_crimes
n_state_st_crimes = set(crimes_by_block['001XX N STATE ST'])

# Print the list
print(n_state_st_crimes)

# Create a unique list of crimes for the second block: w_terminal_st_crimes
w_terminal_st_crimes = set(crimes_by_block['0000X W TERMINAL ST'])

# Print the list
print(w_terminal_st_crimes)

# Find the differences between the two blocks: crime_differences
crime_differences = n_state_st_crimes.difference(w_terminal_st_crimes)

# Print the differences
print(crime_differences)


